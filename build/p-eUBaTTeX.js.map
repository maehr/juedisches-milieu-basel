{"version":3,"file":"p-eUBaTTeX.js","sources":["node_modules/@ionic/core/dist/collection/utils/overlays.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { doc } from \"./browser/index\";\nimport { shouldUseCloseWatcher } from \"./hardware-back-button\";\nimport { config } from \"../global/config\";\nimport { getIonMode } from \"../global/ionic-global\";\nimport { CoreDelegate } from \"./framework-delegate\";\nimport { OVERLAY_BACK_BUTTON_PRIORITY } from \"./hardware-back-button\";\nimport { addEventListener, componentOnReady, focusVisibleElement, getElementRoot, removeEventListener, } from \"./helpers\";\nimport { printIonWarning } from \"./logging\";\nlet lastOverlayIndex = 0;\nlet lastId = 0;\nexport const activeAnimations = new WeakMap();\nconst createController = (tagName) => {\n    return {\n        create(options) {\n            return createOverlay(tagName, options);\n        },\n        dismiss(data, role, id) {\n            return dismissOverlay(document, data, role, tagName, id);\n        },\n        async getTop() {\n            return getPresentedOverlay(document, tagName);\n        },\n    };\n};\nexport const alertController = /*@__PURE__*/ createController('ion-alert');\nexport const actionSheetController = /*@__PURE__*/ createController('ion-action-sheet');\nexport const loadingController = /*@__PURE__*/ createController('ion-loading');\nexport const modalController = /*@__PURE__*/ createController('ion-modal');\nexport const pickerController = /*@__PURE__*/ createController('ion-picker');\nexport const popoverController = /*@__PURE__*/ createController('ion-popover');\nexport const toastController = /*@__PURE__*/ createController('ion-toast');\n/**\n * Prepares the overlay element to be presented.\n */\nexport const prepareOverlay = (el) => {\n    if (typeof document !== 'undefined') {\n        /**\n         * Adds a single instance of event listeners for application behaviors:\n         *\n         * - Escape Key behavior to dismiss an overlay\n         * - Trapping focus within an overlay\n         * - Back button behavior to dismiss an overlay\n         *\n         * This only occurs when the first overlay is created.\n         */\n        connectListeners(document);\n    }\n    const overlayIndex = lastOverlayIndex++;\n    /**\n     * overlayIndex is used in the overlay components to set a zIndex.\n     * This ensures that the most recently presented overlay will be\n     * on top.\n     */\n    el.overlayIndex = overlayIndex;\n};\n/**\n * Assigns an incrementing id to an overlay element, that does not\n * already have an id assigned to it.\n *\n * Used to track unique instances of an overlay element.\n */\nexport const setOverlayId = (el) => {\n    if (!el.hasAttribute('id')) {\n        el.id = `ion-overlay-${++lastId}`;\n    }\n    return el.id;\n};\nexport const createOverlay = (tagName, opts) => {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof window !== 'undefined' && typeof window.customElements !== 'undefined') {\n        return window.customElements.whenDefined(tagName).then(() => {\n            const element = document.createElement(tagName);\n            element.classList.add('overlay-hidden');\n            /**\n             * Convert the passed in overlay options into props\n             * that get passed down into the new overlay.\n             */\n            Object.assign(element, Object.assign(Object.assign({}, opts), { hasController: true }));\n            // append the overlay element to the document body\n            getAppRoot(document).appendChild(element);\n            return new Promise((resolve) => componentOnReady(element, resolve));\n        });\n    }\n    return Promise.resolve();\n};\n/**\n * This query string selects elements that\n * are eligible to receive focus. We select\n * interactive elements that meet the following\n * criteria:\n * 1. Element does not have a negative tabindex\n * 2. Element does not have `hidden`\n * 3. Element does not have `disabled` for non-Ionic components.\n * 4. Element does not have `disabled` or `disabled=\"true\"` for Ionic components.\n * Note: We need this distinction because `disabled=\"false\"` is\n * valid usage for the disabled property on ion-button.\n */\nconst focusableQueryString = '[tabindex]:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), input:not([type=hidden]):not([tabindex^=\"-\"]):not([hidden]):not([disabled]), textarea:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), button:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), select:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable[disabled=\"false\"]:not([tabindex^=\"-\"]):not([hidden])';\nconst isOverlayHidden = (overlay) => overlay.classList.contains('overlay-hidden');\n/**\n * Focuses the first descendant in an overlay\n * that can receive focus. If none exists,\n * the entire overlay will be focused.\n */\nexport const focusFirstDescendant = (ref, overlay) => {\n    const firstInput = ref.querySelector(focusableQueryString);\n    focusElementInOverlay(firstInput, overlay);\n};\n/**\n * Focuses the last descendant in an overlay\n * that can receive focus. If none exists,\n * the entire overlay will be focused.\n */\nconst focusLastDescendant = (ref, overlay) => {\n    const inputs = Array.from(ref.querySelectorAll(focusableQueryString));\n    const lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;\n    focusElementInOverlay(lastInput, overlay);\n};\n/**\n * Focuses a particular element in an overlay. If the element\n * doesn't have anything focusable associated with it then\n * the overlay itself will be focused.\n * This should be used instead of the focus() method\n * on most elements because the focusable element\n * may not be the host element.\n *\n * For example, if an ion-button should be focused\n * then we should actually focus the native <button>\n * element inside of ion-button's shadow root, not\n * the host element itself.\n */\nconst focusElementInOverlay = (hostToFocus, overlay) => {\n    let elementToFocus = hostToFocus;\n    const shadowRoot = hostToFocus === null || hostToFocus === void 0 ? void 0 : hostToFocus.shadowRoot;\n    if (shadowRoot) {\n        // If there are no inner focusable elements, just focus the host element.\n        elementToFocus = shadowRoot.querySelector(focusableQueryString) || hostToFocus;\n    }\n    if (elementToFocus) {\n        focusVisibleElement(elementToFocus);\n    }\n    else {\n        // Focus overlay instead of letting focus escape\n        overlay.focus();\n    }\n};\n/**\n * Traps keyboard focus inside of overlay components.\n * Based on https://w3c.github.io/aria-practices/examples/dialog-modal/alertdialog.html\n * This includes the following components: Action Sheet, Alert, Loading, Modal,\n * Picker, and Popover.\n * Should NOT include: Toast\n */\nconst trapKeyboardFocus = (ev, doc) => {\n    const lastOverlay = getPresentedOverlay(doc, 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover');\n    const target = ev.target;\n    /**\n     * If no active overlay, ignore this event.\n     *\n     * If this component uses the shadow dom,\n     * this global listener is pointless\n     * since it will not catch the focus\n     * traps as they are inside the shadow root.\n     * We need to add a listener to the shadow root\n     * itself to ensure the focus trap works.\n     */\n    if (!lastOverlay || !target) {\n        return;\n    }\n    /**\n     * If the ion-disable-focus-trap class\n     * is present on an overlay, then this component\n     * instance has opted out of focus trapping.\n     * An example of this is when the sheet modal\n     * has a backdrop that is disabled. The content\n     * behind the sheet should be focusable until\n     * the backdrop is enabled.\n     */\n    if (lastOverlay.classList.contains('ion-disable-focus-trap')) {\n        return;\n    }\n    const trapScopedFocus = () => {\n        /**\n         * If we are focusing the overlay, clear\n         * the last focused element so that hitting\n         * tab activates the first focusable element\n         * in the overlay wrapper.\n         */\n        if (lastOverlay === target) {\n            lastOverlay.lastFocus = undefined;\n            /**\n             * Toasts can be presented from an overlay.\n             * However, focus should still be returned to\n             * the overlay when clicking a toast. Normally,\n             * focus would be returned to the last focusable\n             * descendant in the overlay which may not always be\n             * the button that the toast was presented from. In this case,\n             * the focus may be returned to an unexpected element.\n             * To account for this, we make sure to return focus to the\n             * last focused element in the overlay if focus is\n             * moved to the toast.\n             */\n        }\n        else if (target.tagName === 'ION-TOAST') {\n            focusElementInOverlay(lastOverlay.lastFocus, lastOverlay);\n            /**\n             * Otherwise, we must be focusing an element\n             * inside of the overlay. The two possible options\n             * here are an input/button/etc or the ion-focus-trap\n             * element. The focus trap element is used to prevent\n             * the keyboard focus from leaving the overlay when\n             * using Tab or screen assistants.\n             */\n        }\n        else {\n            /**\n             * We do not want to focus the traps, so get the overlay\n             * wrapper element as the traps live outside of the wrapper.\n             */\n            const overlayRoot = getElementRoot(lastOverlay);\n            if (!overlayRoot.contains(target)) {\n                return;\n            }\n            const overlayWrapper = overlayRoot.querySelector('.ion-overlay-wrapper');\n            if (!overlayWrapper) {\n                return;\n            }\n            /**\n             * If the target is inside the wrapper, let the browser\n             * focus as normal and keep a log of the last focused element.\n             * Additionally, if the backdrop was tapped we should not\n             * move focus back inside the wrapper as that could cause\n             * an interactive elements focus state to activate.\n             */\n            if (overlayWrapper.contains(target) || target === overlayRoot.querySelector('ion-backdrop')) {\n                lastOverlay.lastFocus = target;\n            }\n            else {\n                /**\n                 * Otherwise, we must have focused one of the focus traps.\n                 * We need to wrap the focus to either the first element\n                 * or the last element.\n                 */\n                /**\n                 * Once we call `focusFirstDescendant` and focus the first\n                 * descendant, another focus event will fire which will\n                 * cause `lastOverlay.lastFocus` to be updated before\n                 * we can run the code after that. We will cache the value\n                 * here to avoid that.\n                 */\n                const lastFocus = lastOverlay.lastFocus;\n                // Focus the first element in the overlay wrapper\n                focusFirstDescendant(overlayWrapper, lastOverlay);\n                /**\n                 * If the cached last focused element is the\n                 * same as the active element, then we need\n                 * to wrap focus to the last descendant. This happens\n                 * when the first descendant is focused, and the user\n                 * presses Shift + Tab. The previous line will focus\n                 * the same descendant again (the first one), causing\n                 * last focus to equal the active element.\n                 */\n                if (lastFocus === doc.activeElement) {\n                    focusLastDescendant(overlayWrapper, lastOverlay);\n                }\n                lastOverlay.lastFocus = doc.activeElement;\n            }\n        }\n    };\n    const trapShadowFocus = () => {\n        /**\n         * If the target is inside the wrapper, let the browser\n         * focus as normal and keep a log of the last focused element.\n         */\n        if (lastOverlay.contains(target)) {\n            lastOverlay.lastFocus = target;\n            /**\n             * Toasts can be presented from an overlay.\n             * However, focus should still be returned to\n             * the overlay when clicking a toast. Normally,\n             * focus would be returned to the last focusable\n             * descendant in the overlay which may not always be\n             * the button that the toast was presented from. In this case,\n             * the focus may be returned to an unexpected element.\n             * To account for this, we make sure to return focus to the\n             * last focused element in the overlay if focus is\n             * moved to the toast.\n             */\n        }\n        else if (target.tagName === 'ION-TOAST') {\n            focusElementInOverlay(lastOverlay.lastFocus, lastOverlay);\n        }\n        else {\n            /**\n             * Otherwise, we are about to have focus\n             * go out of the overlay. We need to wrap\n             * the focus to either the first element\n             * or the last element.\n             */\n            /**\n             * Once we call `focusFirstDescendant` and focus the first\n             * descendant, another focus event will fire which will\n             * cause `lastOverlay.lastFocus` to be updated before\n             * we can run the code after that. We will cache the value\n             * here to avoid that.\n             */\n            const lastFocus = lastOverlay.lastFocus;\n            // Focus the first element in the overlay wrapper\n            focusFirstDescendant(lastOverlay, lastOverlay);\n            /**\n             * If the cached last focused element is the\n             * same as the active element, then we need\n             * to wrap focus to the last descendant. This happens\n             * when the first descendant is focused, and the user\n             * presses Shift + Tab. The previous line will focus\n             * the same descendant again (the first one), causing\n             * last focus to equal the active element.\n             */\n            if (lastFocus === doc.activeElement) {\n                focusLastDescendant(lastOverlay, lastOverlay);\n            }\n            lastOverlay.lastFocus = doc.activeElement;\n        }\n    };\n    if (lastOverlay.shadowRoot) {\n        trapShadowFocus();\n    }\n    else {\n        trapScopedFocus();\n    }\n};\nconst connectListeners = (doc) => {\n    if (lastOverlayIndex === 0) {\n        lastOverlayIndex = 1;\n        doc.addEventListener('focus', (ev) => {\n            trapKeyboardFocus(ev, doc);\n        }, true);\n        // handle back-button click\n        doc.addEventListener('ionBackButton', (ev) => {\n            const lastOverlay = getPresentedOverlay(doc);\n            if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n                ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {\n                    /**\n                     * Do not return this promise otherwise\n                     * the hardware back button utility will\n                     * be blocked until the overlay dismisses.\n                     * This is important for a modal with canDismiss.\n                     * If the application presents a confirmation alert\n                     * in the \"canDismiss\" callback, then it will be impossible\n                     * to use the hardware back button to dismiss the alert\n                     * dialog because the hardware back button utility\n                     * is blocked on waiting for the modal to dismiss.\n                     */\n                    lastOverlay.dismiss(undefined, BACKDROP);\n                });\n            }\n        });\n        /**\n         * Handle ESC to close overlay.\n         * CloseWatcher also handles pressing the Esc\n         * key, so if a browser supports CloseWatcher then\n         * this behavior will be handled via the ionBackButton\n         * event.\n         */\n        if (!shouldUseCloseWatcher()) {\n            doc.addEventListener('keydown', (ev) => {\n                if (ev.key === 'Escape') {\n                    const lastOverlay = getPresentedOverlay(doc);\n                    if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n                        lastOverlay.dismiss(undefined, BACKDROP);\n                    }\n                }\n            });\n        }\n    }\n};\nexport const dismissOverlay = (doc, data, role, overlayTag, id) => {\n    const overlay = getPresentedOverlay(doc, overlayTag, id);\n    if (!overlay) {\n        return Promise.reject('overlay does not exist');\n    }\n    return overlay.dismiss(data, role);\n};\n/**\n * Returns a list of all overlays in the DOM even if they are not presented.\n */\nexport const getOverlays = (doc, selector) => {\n    if (selector === undefined) {\n        selector = 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast';\n    }\n    return Array.from(doc.querySelectorAll(selector)).filter((c) => c.overlayIndex > 0);\n};\n/**\n * Returns a list of all presented overlays.\n * Inline overlays can exist in the DOM but not be presented,\n * so there are times when we want to exclude those.\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n */\nconst getPresentedOverlays = (doc, overlayTag) => {\n    return getOverlays(doc, overlayTag).filter((o) => !isOverlayHidden(o));\n};\n/**\n * Returns a presented overlay element.\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n * @param id The unique identifier for the overlay instance.\n * @returns The overlay element or `undefined` if no overlay element is found.\n */\nexport const getPresentedOverlay = (doc, overlayTag, id) => {\n    const overlays = getPresentedOverlays(doc, overlayTag);\n    return id === undefined ? overlays[overlays.length - 1] : overlays.find((o) => o.id === id);\n};\n/**\n * When an overlay is presented, the main\n * focus is the overlay not the page content.\n * We need to remove the page content from the\n * accessibility tree otherwise when\n * users use \"read screen from top\" gestures with\n * TalkBack and VoiceOver, the screen reader will begin\n * to read the content underneath the overlay.\n *\n * We need a container where all page components\n * exist that is separate from where the overlays\n * are added in the DOM. For most apps, this element\n * is the top most ion-router-outlet. In the event\n * that devs are not using a router,\n * they will need to add the \"ion-view-container-root\"\n * id to the element that contains all of their views.\n *\n * TODO: If Framework supports having multiple top\n * level router outlets we would need to update this.\n * Example: One outlet for side menu and one outlet\n * for main content.\n */\nexport const setRootAriaHidden = (hidden = false) => {\n    const root = getAppRoot(document);\n    const viewContainer = root.querySelector('ion-router-outlet, ion-nav, #ion-view-container-root');\n    if (!viewContainer) {\n        return;\n    }\n    if (hidden) {\n        viewContainer.setAttribute('aria-hidden', 'true');\n    }\n    else {\n        viewContainer.removeAttribute('aria-hidden');\n    }\n};\nexport const present = async (overlay, name, iosEnterAnimation, mdEnterAnimation, opts) => {\n    var _a, _b;\n    if (overlay.presented) {\n        return;\n    }\n    setRootAriaHidden(true);\n    hideOverlaysFromScreenReaders(overlay.el);\n    overlay.presented = true;\n    overlay.willPresent.emit();\n    (_a = overlay.willPresentShorthand) === null || _a === void 0 ? void 0 : _a.emit();\n    const mode = getIonMode(overlay);\n    // get the user's animation fn if one was provided\n    const animationBuilder = overlay.enterAnimation\n        ? overlay.enterAnimation\n        : config.get(name, mode === 'ios' ? iosEnterAnimation : mdEnterAnimation);\n    const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n    if (completed) {\n        overlay.didPresent.emit();\n        (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();\n    }\n    /**\n     * When an overlay that steals focus\n     * is dismissed, focus should be returned\n     * to the element that was focused\n     * prior to the overlay opening. Toast\n     * does not steal focus and is excluded\n     * from returning focus as a result.\n     */\n    if (overlay.el.tagName !== 'ION-TOAST') {\n        restoreElementFocus(overlay.el);\n    }\n    /**\n     * If the focused element is already\n     * inside the overlay component then\n     * focus should not be moved from that\n     * to the overlay container.\n     */\n    if (overlay.keyboardClose && (document.activeElement === null || !overlay.el.contains(document.activeElement))) {\n        overlay.el.focus();\n    }\n    /**\n     * If this overlay was previously dismissed without being\n     * the topmost one (such as by manually calling dismiss()),\n     * it would still have aria-hidden on being presented again.\n     * Removing it here ensures the overlay is visible to screen\n     * readers.\n     */\n    overlay.el.removeAttribute('aria-hidden');\n};\n/**\n * When an overlay component is dismissed,\n * focus should be returned to the element\n * that presented the overlay. Otherwise\n * focus will be set on the body which\n * means that people using screen readers\n * or tabbing will need to re-navigate\n * to where they were before they\n * opened the overlay.\n */\nconst restoreElementFocus = async (overlayEl) => {\n    let previousElement = document.activeElement;\n    if (!previousElement) {\n        return;\n    }\n    const shadowRoot = previousElement === null || previousElement === void 0 ? void 0 : previousElement.shadowRoot;\n    if (shadowRoot) {\n        // If there are no inner focusable elements, just focus the host element.\n        previousElement = shadowRoot.querySelector(focusableQueryString) || previousElement;\n    }\n    await overlayEl.onDidDismiss();\n    /**\n     * After onDidDismiss, the overlay loses focus\n     * because it is removed from the document\n     *\n     * > An element will also lose focus [...]\n     * > if the element is removed from the document)\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event\n     *\n     * Additionally, `document.activeElement` returns:\n     *\n     * > The Element which currently has focus,\n     * > `<body>` or null if there is\n     * > no focused element.\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement#value\n     *\n     * However, if the user has already focused\n     * an element sometime between onWillDismiss\n     * and onDidDismiss (for example, focusing a\n     * text box after tapping a button in an\n     * action sheet) then don't restore focus to\n     * previous element\n     */\n    if (document.activeElement === null || document.activeElement === document.body) {\n        previousElement.focus();\n    }\n};\nexport const dismiss = async (overlay, data, role, name, iosLeaveAnimation, mdLeaveAnimation, opts) => {\n    var _a, _b;\n    if (!overlay.presented) {\n        return false;\n    }\n    /**\n     * If this is the last visible overlay then\n     * we want to re-add the root to the accessibility tree.\n     */\n    if (doc !== undefined && getPresentedOverlays(doc).length === 1) {\n        setRootAriaHidden(false);\n    }\n    overlay.presented = false;\n    try {\n        // Overlay contents should not be clickable during dismiss\n        overlay.el.style.setProperty('pointer-events', 'none');\n        overlay.willDismiss.emit({ data, role });\n        (_a = overlay.willDismissShorthand) === null || _a === void 0 ? void 0 : _a.emit({ data, role });\n        const mode = getIonMode(overlay);\n        const animationBuilder = overlay.leaveAnimation\n            ? overlay.leaveAnimation\n            : config.get(name, mode === 'ios' ? iosLeaveAnimation : mdLeaveAnimation);\n        // If dismissed via gesture, no need to play leaving animation again\n        if (role !== GESTURE) {\n            await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n        }\n        overlay.didDismiss.emit({ data, role });\n        (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({ data, role });\n        // Get a reference to all animations currently assigned to this overlay\n        // Then tear them down to return the overlay to its initial visual state\n        const animations = activeAnimations.get(overlay) || [];\n        animations.forEach((ani) => ani.destroy());\n        activeAnimations.delete(overlay);\n        /**\n         * Make overlay hidden again in case it is being reused.\n         * We can safely remove pointer-events: none as\n         * overlay-hidden will set display: none.\n         */\n        overlay.el.classList.add('overlay-hidden');\n        overlay.el.style.removeProperty('pointer-events');\n        /**\n         * Clear any focus trapping references\n         * when the overlay is dismissed.\n         */\n        if (overlay.el.lastFocus !== undefined) {\n            overlay.el.lastFocus = undefined;\n        }\n    }\n    catch (err) {\n        console.error(err);\n    }\n    overlay.el.remove();\n    revealOverlaysToScreenReaders();\n    return true;\n};\nconst getAppRoot = (doc) => {\n    return doc.querySelector('ion-app') || doc.body;\n};\nconst overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {\n    // Make overlay visible in case it's hidden\n    baseEl.classList.remove('overlay-hidden');\n    const aniRoot = overlay.el;\n    const animation = animationBuilder(aniRoot, opts);\n    if (!overlay.animated || !config.getBoolean('animated', true)) {\n        animation.duration(0);\n    }\n    if (overlay.keyboardClose) {\n        animation.beforeAddWrite(() => {\n            const activeElement = baseEl.ownerDocument.activeElement;\n            if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.matches('input,ion-input, ion-textarea')) {\n                activeElement.blur();\n            }\n        });\n    }\n    const activeAni = activeAnimations.get(overlay) || [];\n    activeAnimations.set(overlay, [...activeAni, animation]);\n    await animation.play();\n    return true;\n};\nexport const eventMethod = (element, eventName) => {\n    let resolve;\n    const promise = new Promise((r) => (resolve = r));\n    onceEvent(element, eventName, (event) => {\n        resolve(event.detail);\n    });\n    return promise;\n};\nexport const onceEvent = (element, eventName, callback) => {\n    const handler = (ev) => {\n        removeEventListener(element, eventName, handler);\n        callback(ev);\n    };\n    addEventListener(element, eventName, handler);\n};\nexport const isCancel = (role) => {\n    return role === 'cancel' || role === BACKDROP;\n};\nconst defaultGate = (h) => h();\n/**\n * Calls a developer provided method while avoiding\n * Angular Zones. Since the handler is provided by\n * the developer, we should throw any errors\n * received so that developer-provided bug\n * tracking software can log it.\n */\nexport const safeCall = (handler, arg) => {\n    if (typeof handler === 'function') {\n        const jmp = config.get('_zoneGate', defaultGate);\n        return jmp(() => {\n            try {\n                return handler(arg);\n            }\n            catch (e) {\n                throw e;\n            }\n        });\n    }\n    return undefined;\n};\nexport const BACKDROP = 'backdrop';\nexport const GESTURE = 'gesture';\nexport const OVERLAY_GESTURE_PRIORITY = 39;\n/**\n * Creates a delegate controller.\n *\n * Requires that the component has the following properties:\n * - `el: HTMLElement`\n * - `hasController: boolean`\n * - `delegate?: FrameworkDelegate`\n *\n * @param ref The component class instance.\n */\nexport const createDelegateController = (ref) => {\n    let inline = false;\n    let workingDelegate;\n    const coreDelegate = CoreDelegate();\n    /**\n     * Determines whether or not an overlay is being used\n     * inline or via a controller/JS and returns the correct delegate.\n     * By default, subsequent calls to getDelegate will use\n     * a cached version of the delegate.\n     * This is useful for calling dismiss after present,\n     * so that the correct delegate is given.\n     * @param force `true` to force the non-cached version of the delegate.\n     * @returns The delegate to use and whether or not the overlay is inline.\n     */\n    const getDelegate = (force = false) => {\n        if (workingDelegate && !force) {\n            return {\n                delegate: workingDelegate,\n                inline,\n            };\n        }\n        const { el, hasController, delegate } = ref;\n        /**\n         * If using overlay inline\n         * we potentially need to use the coreDelegate\n         * so that this works in vanilla JS apps.\n         * If a developer has presented this component\n         * via a controller, then we can assume\n         * the component is already in the\n         * correct place.\n         */\n        const parentEl = el.parentNode;\n        inline = parentEl !== null && !hasController;\n        workingDelegate = inline ? delegate || coreDelegate : delegate;\n        return { inline, delegate: workingDelegate };\n    };\n    /**\n     * Attaches a component in the DOM. Teleports the component\n     * to the root of the app.\n     * @param component The component to optionally construct and append to the element.\n     */\n    const attachViewToDom = async (component) => {\n        const { delegate } = getDelegate(true);\n        if (delegate) {\n            return await delegate.attachViewToDom(ref.el, component);\n        }\n        const { hasController } = ref;\n        if (hasController && component !== undefined) {\n            throw new Error('framework delegate is missing');\n        }\n        return null;\n    };\n    /**\n     * Moves a component back to its original location in the DOM.\n     */\n    const removeViewFromDom = () => {\n        const { delegate } = getDelegate();\n        if (delegate && ref.el !== undefined) {\n            delegate.removeViewFromDom(ref.el.parentElement, ref.el);\n        }\n    };\n    return {\n        attachViewToDom,\n        removeViewFromDom,\n    };\n};\n/**\n * Constructs a trigger interaction for an overlay.\n * Presents an overlay when the trigger is clicked.\n *\n * Usage:\n * ```ts\n * triggerController = createTriggerController();\n * triggerController.addClickListener(el, trigger);\n * ```\n */\nexport const createTriggerController = () => {\n    let destroyTriggerInteraction;\n    /**\n     * Removes the click listener from the trigger element.\n     */\n    const removeClickListener = () => {\n        if (destroyTriggerInteraction) {\n            destroyTriggerInteraction();\n            destroyTriggerInteraction = undefined;\n        }\n    };\n    /**\n     * Adds a click listener to the trigger element.\n     * Presents the overlay when the trigger is clicked.\n     * @param el The overlay element.\n     * @param trigger The ID of the element to add a click listener to.\n     */\n    const addClickListener = (el, trigger) => {\n        removeClickListener();\n        const triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;\n        if (!triggerEl) {\n            printIonWarning(`A trigger element with the ID \"${trigger}\" was not found in the DOM. The trigger element must be in the DOM when the \"trigger\" property is set on an overlay component.`, el);\n            return;\n        }\n        const configureTriggerInteraction = (targetEl, overlayEl) => {\n            const openOverlay = () => {\n                overlayEl.present();\n            };\n            targetEl.addEventListener('click', openOverlay);\n            return () => {\n                targetEl.removeEventListener('click', openOverlay);\n            };\n        };\n        destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el);\n    };\n    return {\n        addClickListener,\n        removeClickListener,\n    };\n};\n/**\n * Ensure that underlying overlays have aria-hidden if necessary so that screen readers\n * cannot move focus to these elements. Note that we cannot rely on focus/focusin/focusout\n * events here because those events do not fire when the screen readers moves to a non-focusable\n * element such as text.\n * Without this logic screen readers would be able to move focus outside of the top focus-trapped overlay.\n *\n * @param newTopMostOverlay - The overlay that is being presented. Since the overlay has not been\n * fully presented yet at the time this function is called it will not be included in the getPresentedOverlays result.\n */\nconst hideOverlaysFromScreenReaders = (newTopMostOverlay) => {\n    var _a;\n    if (doc === undefined)\n        return;\n    const overlays = getPresentedOverlays(doc);\n    for (let i = overlays.length - 1; i >= 0; i--) {\n        const presentedOverlay = overlays[i];\n        const nextPresentedOverlay = (_a = overlays[i + 1]) !== null && _a !== void 0 ? _a : newTopMostOverlay;\n        /**\n         * If next overlay has aria-hidden then all remaining overlays will have it too.\n         * Or, if the next overlay is a Toast that does not have aria-hidden then current overlay\n         * should not have aria-hidden either so focus can remain in the current overlay.\n         */\n        if (nextPresentedOverlay.hasAttribute('aria-hidden') || nextPresentedOverlay.tagName !== 'ION-TOAST') {\n            presentedOverlay.setAttribute('aria-hidden', 'true');\n        }\n    }\n};\n/**\n * When dismissing an overlay we need to reveal the new top-most overlay to screen readers.\n * If the top-most overlay is a Toast we potentially need to reveal more overlays since\n * focus is never automatically moved to the Toast.\n */\nconst revealOverlaysToScreenReaders = () => {\n    if (doc === undefined)\n        return;\n    const overlays = getPresentedOverlays(doc);\n    for (let i = overlays.length - 1; i >= 0; i--) {\n        const currentOverlay = overlays[i];\n        /**\n         * If the current we are looking at is a Toast then we can remove aria-hidden.\n         * However, we potentially need to keep looking at the overlay stack because there\n         * could be more Toasts underneath. Additionally, we need to unhide the closest non-Toast\n         * overlay too so focus can move there since focus is never automatically moved to the Toast.\n         */\n        currentOverlay.removeAttribute('aria-hidden');\n        /**\n         * If we found a non-Toast element then we can just remove aria-hidden and stop searching entirely\n         * since this overlay should always receive focus. As a result, all underlying overlays should still\n         * be hidden from screen readers.\n         */\n        if (currentOverlay.tagName !== 'ION-TOAST') {\n            break;\n        }\n    }\n};\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}
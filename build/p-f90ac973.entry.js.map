{"version":3,"names":["segmentIosCss","segmentMdCss","Segment","constructor","hostRef","this","onClick","ev","current","target","previous","checked","tagName","value","emitValueChange","scrollable","swipeGesture","checkButton","setCheckedClasses","getSegmentButton","selector","_a","_b","buttons","getButtons","filter","button","disabled","currIndex","findIndex","document","activeElement","length","activated","color","undefined","selectOnFocus","colorChanged","oldValue","emitStyle","swipeGestureChanged","gestureChanged","valueChanged","ionSelect","emit","scrollActiveButtonIntoView","disabledChanged","gesture","enable","connectedCallback","componentWillLoad","componentDidLoad","raf","import","createGesture","el","gestureName","gesturePriority","threshold","passive","onStart","onMove","onEnd","detail","valueBeforeGesture","activate","setNextIndex","setActivated","event","stopImmediatePropagation","ionChange","Array","from","querySelectorAll","find","forEach","classList","add","remove","clicked","getIndicator","root","shadowRoot","querySelector","previousIndicator","currentIndicator","previousClientRect","getBoundingClientRect","currentClientRect","widthDelta","width","xPosition","left","transform","writeTask","style","setProperty","index","next","smoothScroll","activeButton","scrollContainerBox","activeButtonBox","activeButtonLeft","x","centeredX","scrollBy","top","behavior","isEnd","rtl","isRTL","nextIndex","rect","currentX","previousY","height","getRootNode","nextEl","elementFromPoint","decreaseIndex","increaseIndex","newIndex","ionStyle","segment","onKeyDown","keyDownSelectsButton","key","preventDefault","setFocus","render","mode","getIonMode","h","Host","role","class","createColorClasses","hostContext"],"sources":["node_modules/@ionic/core/dist/collection/components/segment/segment.ios.css?tag=ion-segment&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/segment/segment.md.css?tag=ion-segment&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/segment/segment.js"],"sourcesContent":["/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the segment button\n   */\n  --ripple-color: currentColor;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  display: grid;\n  grid-auto-columns: 1fr;\n  position: relative;\n  align-items: stretch;\n  justify-content: center;\n  width: 100%;\n  background: var(--background);\n  font-family: var(--ion-font-family, inherit);\n  text-align: center;\n  contain: paint;\n  user-select: none;\n}\n\n:host(.segment-scrollable) {\n  justify-content: start;\n  width: auto;\n  overflow-x: auto;\n  grid-auto-columns: minmax(min-content, 1fr);\n}\n\n:host(.segment-scrollable::-webkit-scrollbar) {\n  display: none;\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  --background: rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.065);\n  border-radius: 8px;\n  overflow: hidden;\n  z-index: 0;\n}\n\n:host(.ion-color) {\n  background: rgba(var(--ion-color-base-rgb), 0.065);\n}\n\n:host(.in-toolbar) {\n  -webkit-margin-start: auto;\n  margin-inline-start: auto;\n  -webkit-margin-end: auto;\n  margin-inline-end: auto;\n  margin-top: 0;\n  margin-bottom: 0;\n  width: auto;\n}\n\n:host(.in-toolbar:not(.ion-color)) {\n  background: var(--ion-toolbar-segment-background, var(--background));\n}\n\n:host(.in-toolbar-color:not(.ion-color)) {\n  background: rgba(var(--ion-color-contrast-rgb), 0.11);\n}","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the segment button\n   */\n  --ripple-color: currentColor;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  display: grid;\n  grid-auto-columns: 1fr;\n  position: relative;\n  align-items: stretch;\n  justify-content: center;\n  width: 100%;\n  background: var(--background);\n  font-family: var(--ion-font-family, inherit);\n  text-align: center;\n  contain: paint;\n  user-select: none;\n}\n\n:host(.segment-scrollable) {\n  justify-content: start;\n  width: auto;\n  overflow-x: auto;\n  grid-auto-columns: minmax(min-content, 1fr);\n}\n\n:host(.segment-scrollable::-webkit-scrollbar) {\n  display: none;\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  --background: transparent;\n  grid-auto-columns: minmax(auto, 360px);\n}\n\n:host(.in-toolbar) {\n  /**\n   * Segment should inherit the\n   * height of the toolbar.\n   * Note: --min-height is initially\n   * set on ion-toolbar, not ion-segment\n   */\n  min-height: var(--min-height);\n}\n\n:host(.segment-scrollable) ::slotted(ion-segment-button) {\n  min-width: auto;\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h, writeTask } from \"@stencil/core\";\nimport { raf } from \"../../utils/helpers\";\nimport { isRTL } from \"../../utils/rtl/index\";\nimport { createColorClasses, hostContext } from \"../../utils/theme\";\nimport { getIonMode } from \"../../global/ionic-global\";\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n */\nexport class Segment {\n    constructor() {\n        this.onClick = (ev) => {\n            const current = ev.target;\n            const previous = this.checked;\n            // If the current element is a segment then that means\n            // the user tried to swipe to a segment button and\n            // click a segment button at the same time so we should\n            // not update the checked segment button\n            if (current.tagName === 'ION-SEGMENT') {\n                return;\n            }\n            this.value = current.value;\n            if (current !== previous) {\n                this.emitValueChange();\n            }\n            if (this.scrollable || !this.swipeGesture) {\n                if (previous) {\n                    this.checkButton(previous, current);\n                }\n                else {\n                    this.setCheckedClasses();\n                }\n            }\n        };\n        this.getSegmentButton = (selector) => {\n            var _a, _b;\n            const buttons = this.getButtons().filter((button) => !button.disabled);\n            const currIndex = buttons.findIndex((button) => button === document.activeElement);\n            switch (selector) {\n                case 'first':\n                    return buttons[0];\n                case 'last':\n                    return buttons[buttons.length - 1];\n                case 'next':\n                    return (_a = buttons[currIndex + 1]) !== null && _a !== void 0 ? _a : buttons[0];\n                case 'previous':\n                    return (_b = buttons[currIndex - 1]) !== null && _b !== void 0 ? _b : buttons[buttons.length - 1];\n                default:\n                    return null;\n            }\n        };\n        this.activated = false;\n        this.color = undefined;\n        this.disabled = false;\n        this.scrollable = false;\n        this.swipeGesture = true;\n        this.value = undefined;\n        this.selectOnFocus = false;\n    }\n    colorChanged(value, oldValue) {\n        /**\n         * If color is set after not having\n         * previously been set (or vice versa),\n         * we need to emit style so the segment-buttons\n         * can apply their color classes properly.\n         */\n        if ((oldValue === undefined && value !== undefined) || (oldValue !== undefined && value === undefined)) {\n            this.emitStyle();\n        }\n    }\n    swipeGestureChanged() {\n        this.gestureChanged();\n    }\n    valueChanged(value) {\n        /**\n         * `ionSelect` is emitted every time the value changes (internal or external changes).\n         * Used by `ion-segment-button` to determine if the button should be checked.\n         */\n        this.ionSelect.emit({ value });\n        this.scrollActiveButtonIntoView();\n    }\n    disabledChanged() {\n        this.gestureChanged();\n        const buttons = this.getButtons();\n        for (const button of buttons) {\n            button.disabled = this.disabled;\n        }\n    }\n    gestureChanged() {\n        if (this.gesture) {\n            this.gesture.enable(!this.scrollable && !this.disabled && this.swipeGesture);\n        }\n    }\n    connectedCallback() {\n        this.emitStyle();\n    }\n    componentWillLoad() {\n        this.emitStyle();\n    }\n    async componentDidLoad() {\n        this.setCheckedClasses();\n        /**\n         * If the value changes before watchers\n         * are setup, then the ionSelect watch callback\n         * will not fire. As a result, we manually\n         * fire this event when Select is loaded.\n         */\n        this.ionSelect.emit({ value: this.value });\n        /**\n         * We need to wait for the buttons to all be rendered\n         * before we can scroll.\n         */\n        raf(() => {\n            /**\n             * When the segment loads for the first\n             * time we just want to snap the active button into\n             * place instead of scroll. Smooth scrolling should only\n             * happen when the user interacts with the segment.\n             */\n            this.scrollActiveButtonIntoView(false);\n        });\n        this.gesture = (await import('../../utils/gesture')).createGesture({\n            el: this.el,\n            gestureName: 'segment',\n            gesturePriority: 100,\n            threshold: 0,\n            passive: false,\n            onStart: (ev) => this.onStart(ev),\n            onMove: (ev) => this.onMove(ev),\n            onEnd: (ev) => this.onEnd(ev),\n        });\n        this.gestureChanged();\n        if (this.disabled) {\n            this.disabledChanged();\n        }\n    }\n    onStart(detail) {\n        this.valueBeforeGesture = this.value;\n        this.activate(detail);\n    }\n    onMove(detail) {\n        this.setNextIndex(detail);\n    }\n    onEnd(detail) {\n        this.setActivated(false);\n        this.setNextIndex(detail, true);\n        detail.event.stopImmediatePropagation();\n        const value = this.value;\n        if (value !== undefined) {\n            if (this.valueBeforeGesture !== value) {\n                this.emitValueChange();\n            }\n        }\n        this.valueBeforeGesture = undefined;\n    }\n    /**\n     * Emits an `ionChange` event.\n     *\n     * This API should be called for user committed changes.\n     * This API should not be used for external value changes.\n     */\n    emitValueChange() {\n        const { value } = this;\n        this.ionChange.emit({ value });\n    }\n    getButtons() {\n        return Array.from(this.el.querySelectorAll('ion-segment-button'));\n    }\n    get checked() {\n        return this.getButtons().find((button) => button.value === this.value);\n    }\n    /*\n     * Activate both the segment and the buttons\n     * due to a bug with ::slotted in Safari\n     */\n    setActivated(activated) {\n        const buttons = this.getButtons();\n        buttons.forEach((button) => {\n            if (activated) {\n                button.classList.add('segment-button-activated');\n            }\n            else {\n                button.classList.remove('segment-button-activated');\n            }\n        });\n        this.activated = activated;\n    }\n    activate(detail) {\n        const clicked = detail.event.target;\n        const buttons = this.getButtons();\n        const checked = buttons.find((button) => button.value === this.value);\n        // Make sure we are only checking for activation on a segment button\n        // since disabled buttons will get the click on the segment\n        if (clicked.tagName !== 'ION-SEGMENT-BUTTON') {\n            return;\n        }\n        // If there are no checked buttons, set the current button to checked\n        if (!checked) {\n            this.value = clicked.value;\n            this.setCheckedClasses();\n        }\n        // If the gesture began on the clicked button with the indicator\n        // then we should activate the indicator\n        if (this.value === clicked.value) {\n            this.setActivated(true);\n        }\n    }\n    getIndicator(button) {\n        const root = button.shadowRoot || button;\n        return root.querySelector('.segment-button-indicator');\n    }\n    checkButton(previous, current) {\n        const previousIndicator = this.getIndicator(previous);\n        const currentIndicator = this.getIndicator(current);\n        if (previousIndicator === null || currentIndicator === null) {\n            return;\n        }\n        const previousClientRect = previousIndicator.getBoundingClientRect();\n        const currentClientRect = currentIndicator.getBoundingClientRect();\n        const widthDelta = previousClientRect.width / currentClientRect.width;\n        const xPosition = previousClientRect.left - currentClientRect.left;\n        // Scale the indicator width to match the previous indicator width\n        // and translate it on top of the previous indicator\n        const transform = `translate3d(${xPosition}px, 0, 0) scaleX(${widthDelta})`;\n        writeTask(() => {\n            // Remove the transition before positioning on top of the previous indicator\n            currentIndicator.classList.remove('segment-button-indicator-animated');\n            currentIndicator.style.setProperty('transform', transform);\n            // Force a repaint to ensure the transform happens\n            currentIndicator.getBoundingClientRect();\n            // Add the transition to move the indicator into place\n            currentIndicator.classList.add('segment-button-indicator-animated');\n            // Remove the transform to slide the indicator back to the button clicked\n            currentIndicator.style.setProperty('transform', '');\n        });\n        this.value = current.value;\n        this.setCheckedClasses();\n    }\n    setCheckedClasses() {\n        const buttons = this.getButtons();\n        const index = buttons.findIndex((button) => button.value === this.value);\n        const next = index + 1;\n        for (const button of buttons) {\n            button.classList.remove('segment-button-after-checked');\n        }\n        if (next < buttons.length) {\n            buttons[next].classList.add('segment-button-after-checked');\n        }\n    }\n    scrollActiveButtonIntoView(smoothScroll = true) {\n        const { scrollable, value, el } = this;\n        if (scrollable) {\n            const buttons = this.getButtons();\n            const activeButton = buttons.find((button) => button.value === value);\n            if (activeButton !== undefined) {\n                const scrollContainerBox = el.getBoundingClientRect();\n                const activeButtonBox = activeButton.getBoundingClientRect();\n                /**\n                 * Subtract the active button x position from the scroll\n                 * container x position. This will give us the x position\n                 * of the active button within the scroll container.\n                 */\n                const activeButtonLeft = activeButtonBox.x - scrollContainerBox.x;\n                /**\n                 * If we just used activeButtonLeft, then the active button\n                 * would be aligned with the left edge of the scroll container.\n                 * Instead, we want the segment button to be centered. As a result,\n                 * we subtract half of the scroll container width. This will position\n                 * the left edge of the active button at the midpoint of the scroll container.\n                 * We then add half of the active button width. This will position the active\n                 * button such that the midpoint of the active button is at the midpoint of the\n                 * scroll container.\n                 */\n                const centeredX = activeButtonLeft - scrollContainerBox.width / 2 + activeButtonBox.width / 2;\n                /**\n                 * We intentionally use scrollBy here instead of scrollIntoView\n                 * to avoid a WebKit bug where accelerated animations break\n                 * when using scrollIntoView. Using scrollIntoView will cause the\n                 * segment container to jump during the transition and then snap into place.\n                 * This is because scrollIntoView can potentially cause parent element\n                 * containers to also scroll. scrollBy does not have this same behavior, so\n                 * we use this API instead.\n                 *\n                 * Note that if there is not enough scrolling space to center the element\n                 * within the scroll container, the browser will attempt\n                 * to center by as much as it can.\n                 */\n                el.scrollBy({\n                    top: 0,\n                    left: centeredX,\n                    behavior: smoothScroll ? 'smooth' : 'instant',\n                });\n            }\n        }\n    }\n    setNextIndex(detail, isEnd = false) {\n        const rtl = isRTL(this.el);\n        const activated = this.activated;\n        const buttons = this.getButtons();\n        const index = buttons.findIndex((button) => button.value === this.value);\n        const previous = buttons[index];\n        let current;\n        let nextIndex;\n        if (index === -1) {\n            return;\n        }\n        // Get the element that the touch event started on in case\n        // it was the checked button, then we will move the indicator\n        const rect = previous.getBoundingClientRect();\n        const left = rect.left;\n        const width = rect.width;\n        // Get the element that the gesture is on top of based on the currentX of the\n        // gesture event and the Y coordinate of the starting element, since the gesture\n        // can move up and down off of the segment\n        const currentX = detail.currentX;\n        const previousY = rect.top + rect.height / 2;\n        /**\n         * Segment can be used inside the shadow dom\n         * so doing document.elementFromPoint would never\n         * return a segment button in that instance.\n         * We use getRootNode to which will return the parent\n         * shadow root if used inside a shadow component and\n         * returns document otherwise.\n         */\n        const root = this.el.getRootNode();\n        const nextEl = root.elementFromPoint(currentX, previousY);\n        const decreaseIndex = rtl ? currentX > left + width : currentX < left;\n        const increaseIndex = rtl ? currentX < left : currentX > left + width;\n        // If the indicator is currently activated then we have started the gesture\n        // on top of the checked button so we need to slide the indicator\n        // by checking the button next to it as we move\n        if (activated && !isEnd) {\n            // Decrease index, move left in LTR & right in RTL\n            if (decreaseIndex) {\n                const newIndex = index - 1;\n                if (newIndex >= 0) {\n                    nextIndex = newIndex;\n                }\n                // Increase index, moves right in LTR & left in RTL\n            }\n            else if (increaseIndex) {\n                if (activated && !isEnd) {\n                    const newIndex = index + 1;\n                    if (newIndex < buttons.length) {\n                        nextIndex = newIndex;\n                    }\n                }\n            }\n            if (nextIndex !== undefined && !buttons[nextIndex].disabled) {\n                current = buttons[nextIndex];\n            }\n        }\n        // If the indicator is not activated then we will just set the indicator\n        // to the element where the gesture ended\n        if (!activated && isEnd) {\n            current = nextEl;\n        }\n        if (current != null) {\n            /**\n             * If current element is ion-segment then that means\n             * user tried to select a disabled ion-segment-button,\n             * and we should not update the ripple.\n             */\n            if (current.tagName === 'ION-SEGMENT') {\n                return false;\n            }\n            if (previous !== current) {\n                this.checkButton(previous, current);\n            }\n        }\n        return true;\n    }\n    emitStyle() {\n        this.ionStyle.emit({\n            segment: true,\n        });\n    }\n    onKeyDown(ev) {\n        const rtl = isRTL(this.el);\n        let keyDownSelectsButton = this.selectOnFocus;\n        let current;\n        switch (ev.key) {\n            case 'ArrowRight':\n                ev.preventDefault();\n                current = rtl ? this.getSegmentButton('previous') : this.getSegmentButton('next');\n                break;\n            case 'ArrowLeft':\n                ev.preventDefault();\n                current = rtl ? this.getSegmentButton('next') : this.getSegmentButton('previous');\n                break;\n            case 'Home':\n                ev.preventDefault();\n                current = this.getSegmentButton('first');\n                break;\n            case 'End':\n                ev.preventDefault();\n                current = this.getSegmentButton('last');\n                break;\n            case ' ':\n            case 'Enter':\n                ev.preventDefault();\n                current = document.activeElement;\n                keyDownSelectsButton = true;\n            default:\n                break;\n        }\n        if (!current) {\n            return;\n        }\n        if (keyDownSelectsButton) {\n            const previous = this.checked;\n            this.checkButton(previous || current, current);\n            if (current !== previous) {\n                this.emitValueChange();\n            }\n        }\n        current.setFocus();\n    }\n    render() {\n        const mode = getIonMode(this);\n        return (h(Host, { key: '01c94f9fcc51fb5a7612588c87155a130b7c8a9d', role: \"tablist\", onClick: this.onClick, class: createColorClasses(this.color, {\n                [mode]: true,\n                'in-toolbar': hostContext('ion-toolbar', this.el),\n                'in-toolbar-color': hostContext('ion-toolbar[color]', this.el),\n                'segment-activated': this.activated,\n                'segment-disabled': this.disabled,\n                'segment-scrollable': this.scrollable,\n            }) }, h(\"slot\", { key: 'b0afdfcb7506a765df42d1d6eb4e1d81bf8fd92a' })));\n    }\n    static get is() { return \"ion-segment\"; }\n    static get encapsulation() { return \"shadow\"; }\n    static get originalStyleUrls() {\n        return {\n            \"ios\": [\"segment.ios.scss\"],\n            \"md\": [\"segment.md.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"ios\": [\"segment.ios.css\"],\n            \"md\": [\"segment.md.css\"]\n        };\n    }\n    static get properties() {\n        return {\n            \"color\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"Color\",\n                    \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n                    \"references\": {\n                        \"Color\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::Color\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n                },\n                \"attribute\": \"color\",\n                \"reflect\": true\n            },\n            \"disabled\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the user cannot interact with the segment.\"\n                },\n                \"attribute\": \"disabled\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"scrollable\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the segment buttons will overflow and the user can swipe to see them.\\nIn addition, this will disable the gesture to drag the indicator between the buttons\\nin order to swipe to see hidden buttons.\"\n                },\n                \"attribute\": \"scrollable\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"swipeGesture\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, users will be able to swipe between segment buttons to activate them.\"\n                },\n                \"attribute\": \"swipe-gesture\",\n                \"reflect\": false,\n                \"defaultValue\": \"true\"\n            },\n            \"value\": {\n                \"type\": \"any\",\n                \"mutable\": true,\n                \"complexType\": {\n                    \"original\": \"SegmentValue\",\n                    \"resolved\": \"number | string | undefined\",\n                    \"references\": {\n                        \"SegmentValue\": {\n                            \"location\": \"import\",\n                            \"path\": \"./segment-interface\",\n                            \"id\": \"src/components/segment/segment-interface.ts::SegmentValue\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"the value of the segment.\"\n                },\n                \"attribute\": \"value\",\n                \"reflect\": false\n            },\n            \"selectOnFocus\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, navigating to an `ion-segment-button` with the keyboard will focus and select the element.\\nIf `false`, keyboard navigation will only focus the `ion-segment-button` element.\"\n                },\n                \"attribute\": \"select-on-focus\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            }\n        };\n    }\n    static get states() {\n        return {\n            \"activated\": {}\n        };\n    }\n    static get events() {\n        return [{\n                \"method\": \"ionChange\",\n                \"name\": \"ionChange\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the value property has changed and any\\ndragging pointer has been released from `ion-segment`.\"\n                },\n                \"complexType\": {\n                    \"original\": \"SegmentChangeEventDetail\",\n                    \"resolved\": \"SegmentChangeEventDetail\",\n                    \"references\": {\n                        \"SegmentChangeEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./segment-interface\",\n                            \"id\": \"src/components/segment/segment-interface.ts::SegmentChangeEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionSelect\",\n                \"name\": \"ionSelect\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"Emitted when the value of the segment changes from user committed actions\\nor from externally assigning a value.\"\n                },\n                \"complexType\": {\n                    \"original\": \"SegmentChangeEventDetail\",\n                    \"resolved\": \"SegmentChangeEventDetail\",\n                    \"references\": {\n                        \"SegmentChangeEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./segment-interface\",\n                            \"id\": \"src/components/segment/segment-interface.ts::SegmentChangeEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionStyle\",\n                \"name\": \"ionStyle\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"Emitted when the styles change.\"\n                },\n                \"complexType\": {\n                    \"original\": \"StyleEventDetail\",\n                    \"resolved\": \"StyleEventDetail\",\n                    \"references\": {\n                        \"StyleEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::StyleEventDetail\"\n                        }\n                    }\n                }\n            }];\n    }\n    static get elementRef() { return \"el\"; }\n    static get watchers() {\n        return [{\n                \"propName\": \"color\",\n                \"methodName\": \"colorChanged\"\n            }, {\n                \"propName\": \"swipeGesture\",\n                \"methodName\": \"swipeGestureChanged\"\n            }, {\n                \"propName\": \"value\",\n                \"methodName\": \"valueChanged\"\n            }, {\n                \"propName\": \"disabled\",\n                \"methodName\": \"disabledChanged\"\n            }];\n    }\n    static get listeners() {\n        return [{\n                \"name\": \"keydown\",\n                \"method\": \"onKeyDown\",\n                \"target\": undefined,\n                \"capture\": false,\n                \"passive\": false\n            }];\n    }\n}\n"],"mappings":"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","ignoreList":[]}
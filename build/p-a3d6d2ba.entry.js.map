{"version":3,"names":["getDecimalPlaces","n","toString","split","length","roundToMaxDecimalPlaces","references","maxPlaces","Math","max","map","r","Number","toFixed","rangeIosCss","rangeMdCss","Range","constructor","hostRef","this","rangeId","rangeIds","didLoad","noUpdate","hasFocus","inheritedAttributes","contentEl","initialContentScrollY","hasLoggedDeprecationWarning","clampBounds","value","clamp","min","ensureValueInBounds","dualKnobs","lower","upper","setupGesture","async","rangeSlider","gesture","import","createGesture","el","gestureName","gesturePriority","threshold","onStart","onMove","ev","onEnd","enable","disabled","handleKeyboard","knob","isIncrease","step","ratioA","ratioB","ionKnobMoveStart","emit","updateValue","emitValueChange","ionKnobMoveEnd","onBlur","ionBlur","emitStyle","onFocus","ionFocus","pressedKnob","undefined","color","debounce","name","label","pin","pinFormatter","round","snaps","ticks","activeBarStart","labelPlacement","legacy","debounceChanged","ionInput","originalIonInput","debounceEvent","minChanged","updateRatio","maxChanged","activeBarStartChanged","printIonWarning","disabledChanged","valueChanged","componentWillLoad","hasAttribute","getAttribute","inheritAriaAttributes","componentDidLoad","connectedCallback","legacyFormController","createLegacyFormController","findClosestIonContent","disconnectedCallback","destroy","getValue","_a","hasLegacyControl","ionStyle","interactive","ionChange","detail","currentX","disableContentScrollY","setPressedKnob","update","clientX","resetContentScrollY","rect","ratio","left","width","isRTL","valueToRatio","ratioToValue","getBoundingClientRect","abs","setFocus","valA","valB","ratioLower","ratioUpper","shadowRoot","knobEl","querySelector","focus","renderLegacyRange","mode","getIonMode","renderHiddenInput","JSON","stringify","h","Host","onFocusin","onFocusout","id","class","createColorClasses","hostContext","renderRangeSlider","hasStartSlotContent","hasEndSlotContent","renderRange","hasLabel","inItem","hasStartContent","needsStartAdjustment","hasEndContent","needsEndAdjustment","part","labelText","getAriaLabel","barStart","barEnd","rtl","start","end","tickStyle","tick","barStyle","ratioMin","ratioMax","active","push","labelledBy","ref","rangeEl","onPointerUp","style","role","renderKnob","pressed","render","knobStyle","onKeyDown","key","preventDefault","stopPropagation","tabindex","clampedValue"],"sources":["node_modules/@ionic/core/dist/collection/utils/floating-point/index.js","node_modules/@ionic/core/dist/collection/components/range/range.ios.css?tag=ion-range&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/range/range.md.css?tag=ion-range&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/range/range.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nexport function getDecimalPlaces(n) {\n    if (n % 1 === 0)\n        return 0;\n    return n.toString().split('.')[1].length;\n}\n/**\n * Fixes floating point rounding errors in a result by rounding\n * to the same specificity, or number of decimal places (*not*\n * significant figures) as provided reference numbers. If multiple\n * references are provided, the highest number of decimal places\n * between them will be used.\n *\n * The main use case is when numbers x and y are added to produce n,\n * but x and y are floats, so n may have rounding errors (such as\n * 3.1000000004 instead of 3.1). As long as only addition/subtraction\n * occurs between x and y, the specificity of the result will never\n * increase, so x and y should be passed in as the references.\n *\n * If multiplication, division, or other operations were used to\n * calculate n, the rounded result may have less specificity than\n * desired. For example, 1 / 3 = 0.33333(...), but\n * roundToMaxDecimalPlaces((1 / 3), 1, 3) will return 0, since both\n * 1 and 3 are whole numbers.\n *\n * Note that extremely precise reference numbers may lead to rounding\n * errors not being trimmed, due to the error result having the same or\n * fewer decimal places as the reference(s). This is acceptable as we\n * would not be able to tell the difference between a rounding error\n * and correct value in this case, but it does mean there is an implicit\n * precision limit. If precision that high is needed, it is recommended\n * to use a third party data type designed to handle floating point\n * errors instead.\n *\n * @param n The number to round.\n * @param references Number(s) used to calculate n, or that should otherwise\n * be used as a reference for the desired specificity.\n */\nexport function roundToMaxDecimalPlaces(n, ...references) {\n    const maxPlaces = Math.max(...references.map((r) => getDecimalPlaces(r)));\n    return Number(n.toFixed(maxPlaces));\n}\n","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --bar-background: Background of the range bar\n   * @prop --bar-background-active: Background of the active range bar\n   * @prop --bar-height: Height of the range bar\n   * @prop --bar-border-radius: Border radius of the range bar\n   * @prop --height: Height of the range\n   * @prop --knob-background: Background of the range knob\n   * @prop --knob-border-radius: Border radius of the range knob\n   * @prop --knob-box-shadow: Box shadow of the range knob\n   * @prop --knob-size: Size of the range knob\n   * @prop --pin-background: Background of the range pin (only available in MD mode)\n   * @prop --pin-color: Color of the range pin (only available in MD mode)\n   */\n  --knob-handle-size: calc(var(--knob-size) * 2);\n  display: flex;\n  position: relative;\n  flex: 3;\n  align-items: center;\n  font-family: var(--ion-font-family, inherit);\n  user-select: none;\n  z-index: 2;\n}\n\n:host(.range-disabled) {\n  pointer-events: none;\n}\n\n::slotted(ion-label) {\n  flex: initial;\n}\n\n::slotted(ion-icon[slot]) {\n  font-size: 24px;\n}\n\n.range-slider {\n  position: relative;\n  flex: 1;\n  width: 100%;\n  height: var(--height);\n  contain: size layout style;\n  cursor: grab;\n  touch-action: pan-y;\n}\n\n:host(.range-pressed) .range-slider {\n  cursor: grabbing;\n}\n\n.range-pin {\n  position: absolute;\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n  text-align: center;\n  box-sizing: border-box;\n}\n\n.range-knob-handle {\n  top: calc((var(--height) - var(--knob-handle-size)) / 2);\n  -webkit-margin-start: calc(0px - var(--knob-handle-size) / 2);\n  margin-inline-start: calc(0px - var(--knob-handle-size) / 2);\n  display: flex;\n  position: absolute;\n  justify-content: center;\n  width: var(--knob-handle-size);\n  height: var(--knob-handle-size);\n  text-align: center;\n}\n@supports (inset-inline-start: 0) {\n  .range-knob-handle {\n    inset-inline-start: 0;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .range-knob-handle {\n    left: 0;\n  }\n  :host-context([dir=rtl]) .range-knob-handle {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  [dir=rtl] .range-knob-handle {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  @supports selector(:dir(rtl)) {\n    .range-knob-handle:dir(rtl) {\n      left: unset;\n      right: unset;\n      right: 0;\n    }\n  }\n}\n:host-context([dir=rtl]) .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-knob-handle:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n.range-knob-handle:active, .range-knob-handle:focus {\n  outline: none;\n}\n\n.range-bar-container {\n  border-radius: var(--bar-border-radius);\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n}\n@supports (inset-inline-start: 0) {\n  .range-bar-container {\n    inset-inline-start: 0;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .range-bar-container {\n    left: 0;\n  }\n  :host-context([dir=rtl]) .range-bar-container {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  [dir=rtl] .range-bar-container {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  @supports selector(:dir(rtl)) {\n    .range-bar-container:dir(rtl) {\n      left: unset;\n      right: unset;\n      right: 0;\n    }\n  }\n}\n:host-context([dir=rtl]) .range-bar-container {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-bar-container {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-bar-container:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n.range-bar {\n  border-radius: var(--bar-border-radius);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n  background: var(--bar-background);\n  pointer-events: none;\n}\n\n.range-knob {\n  border-radius: var(--knob-border-radius);\n  top: calc(50% - var(--knob-size) / 2);\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  background: var(--knob-background);\n  box-shadow: var(--knob-box-shadow);\n  z-index: 2;\n  pointer-events: none;\n}\n@supports (inset-inline-start: 0) {\n  .range-knob {\n    inset-inline-start: calc(50% - var(--knob-size) / 2);\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .range-knob {\n    left: calc(50% - var(--knob-size) / 2);\n  }\n  :host-context([dir=rtl]) .range-knob {\n    left: unset;\n    right: unset;\n    right: calc(50% - var(--knob-size) / 2);\n  }\n  [dir=rtl] .range-knob {\n    left: unset;\n    right: unset;\n    right: calc(50% - var(--knob-size) / 2);\n  }\n  @supports selector(:dir(rtl)) {\n    .range-knob:dir(rtl) {\n      left: unset;\n      right: unset;\n      right: calc(50% - var(--knob-size) / 2);\n    }\n  }\n}\n:host-context([dir=rtl]) .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-knob:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n:host(.range-pressed) .range-bar-active {\n  will-change: left, right;\n}\n\n:host(.in-item) {\n  width: 100%;\n}\n\n/**\n * Range can be slotted\n * in components such as item and\n * toolbar which is why we do not\n * limit the below behavior to just ion-item.\n */\n:host([slot=start]),\n:host([slot=end]) {\n  width: auto;\n}\n\n:host(.in-item) ::slotted(ion-label) {\n  align-self: center;\n}\n\n.range-wrapper {\n  display: flex;\n  position: relative;\n  flex-grow: 1;\n  align-items: center;\n  height: inherit;\n}\n\n::slotted([slot=label]) {\n  /**\n   * Label text should not extend\n   * beyond the bounds of the range.\n   * However, we do not set the max\n   * width to 100% because then\n   * only the label would show and users\n   * would not be able to see the range.\n   */\n  max-width: 200px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n\n/**\n * If no label text is placed into the slot\n * then the element should be hidden otherwise\n * there will be additional margins added.\n */\n.label-text-wrapper-hidden {\n  display: none;\n}\n\n.native-wrapper {\n  display: flex;\n  flex-grow: 1;\n  align-items: center;\n}\n\n/**\n * Label is on the left of the range in LTR and\n * on the right in RTL.\n */\n:host(.range-label-placement-start) .range-wrapper {\n  flex-direction: row;\n}\n\n:host(.range-label-placement-start) .label-text-wrapper {\n  /**\n   * The margin between the label and\n   * the range should be on the end\n   * when the label sits at the start.\n   */\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n/**\n * Label is on the right of the range in LTR and\n * on the left in RTL.\n */\n:host(.range-label-placement-end) .range-wrapper {\n  flex-direction: row-reverse;\n}\n\n/**\n * The margin between the label and\n * the range should be on the start\n * when the label sits at the end.\n */\n:host(.range-label-placement-end) .label-text-wrapper {\n  -webkit-margin-start: 16px;\n  margin-inline-start: 16px;\n  -webkit-margin-end: 0;\n  margin-inline-end: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n:host(.range-label-placement-fixed) .label-text-wrapper {\n  /**\n   * The margin between the label and\n   * the range should be on the end\n   * when the label sits at the start.\n   */\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n/**\n * Label is on the left of the range in LTR and\n * on the right in RTL. Label also has a fixed width.\n */\n:host(.range-label-placement-fixed) .label-text-wrapper {\n  flex: 0 0 100px;\n  width: 100px;\n  min-width: 100px;\n  max-width: 200px;\n}\n\n/**\n * Label is on top of the range.\n */\n:host(.range-label-placement-stacked) .range-wrapper {\n  flex-direction: column;\n  align-items: stretch;\n}\n\n:host(.range-label-placement-stacked) .label-text-wrapper {\n  transform-origin: left top;\n  transform: scale(0.75);\n  /**\n  * The margin between the label and\n  * the range should be on the bottom\n  * when the label sits on top.\n  */\n  margin-left: 0;\n  margin-right: 0;\n  margin-bottom: 16px;\n  /**\n   * Label text should not extend\n   * beyond the bounds of the range.\n   */\n  max-width: calc(100% / 0.75);\n}\n:host-context([dir=rtl]):host(.range-label-placement-stacked) .label-text-wrapper, :host-context([dir=rtl]).range-label-placement-stacked .label-text-wrapper {\n  transform-origin: right top;\n}\n\n@supports selector(:dir(rtl)) {\n  :host(.range-label-placement-stacked:dir(rtl)) .label-text-wrapper {\n    transform-origin: right top;\n  }\n}\n\n:host(.in-item.range-label-placement-stacked) .label-text-wrapper {\n  margin-top: 10px;\n  margin-bottom: 16px;\n}\n\n:host(.in-item.range-label-placement-stacked) .native-wrapper {\n  margin-bottom: 0px;\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n/**\n * 24px was chosen so the knob and its\n * shadow do not get cut off by the item.\n */\n:host {\n  --knob-border-radius: 50%;\n  --knob-background: #ffffff;\n  --knob-box-shadow: 0px 0.5px 4px rgba(0, 0, 0, 0.12), 0px 6px 13px rgba(0, 0, 0, 0.12);\n  --knob-size: 26px;\n  --bar-height: 4px;\n  --bar-background: var(--ion-color-step-900, #e6e6e6);\n  --bar-background-active: var(--ion-color-primary, #3880ff);\n  --bar-border-radius: 2px;\n  --height: 42px;\n}\n\n:host(.legacy-range) {\n  -webkit-padding-start: 16px;\n  padding-inline-start: 16px;\n  -webkit-padding-end: 16px;\n  padding-inline-end: 16px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n\n:host(.range-item-start-adjustment) {\n  -webkit-padding-start: 24px;\n  padding-inline-start: 24px;\n}\n\n:host(.range-item-end-adjustment) {\n  -webkit-padding-end: 24px;\n  padding-inline-end: 24px;\n}\n\n:host(.ion-color) .range-bar-active,\n:host(.ion-color) .range-tick-active {\n  background: var(--ion-color-base);\n}\n\n::slotted([slot=start]) {\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n::slotted([slot=end]) {\n  -webkit-margin-start: 16px;\n  margin-inline-start: 16px;\n  -webkit-margin-end: 0;\n  margin-inline-end: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n:host(.range-has-pin:not(.range-label-placement-stacked)) {\n  /**\n  * The pin should not overlap any elements that are\n  * above the range. By adding padding to the top of the\n  * range, it provides a buffer for the pin to move into\n  * when it is pressed.\n  *\n  * The padding is not included when the label is stacked\n  * because the pin is below the label.\n  * It still requires a buffer to prevent the pin from\n  * overlapping the range. The buffer is added to the\n  * bottom of the range label instead of the host.\n  */\n  padding-top: calc(8px + 0.75rem);\n}\n\n:host(.range-has-pin.range-label-placement-stacked) .label-text-wrapper {\n  /**\n  * The pin should not overlap the stacked label. By adding\n  * margin to the bottom of the label, it provides a buffer\n  * for the pin to move into when it is pressed.\n  */\n  margin-bottom: calc(8px + 0.75rem);\n}\n\n.range-bar-active {\n  bottom: 0;\n  width: auto;\n  background: var(--bar-background-active);\n}\n.range-bar-active.has-ticks {\n  border-radius: 0;\n  -webkit-margin-start: -2px;\n  margin-inline-start: -2px;\n  -webkit-margin-end: -2px;\n  margin-inline-end: -2px;\n}\n\n.range-tick {\n  -webkit-margin-start: -2px;\n  margin-inline-start: -2px;\n  border-radius: 0;\n  position: absolute;\n  top: 17px;\n  width: 4px;\n  height: 8px;\n  background: var(--ion-color-step-900, #e6e6e6);\n  pointer-events: none;\n}\n\n.range-tick-active {\n  background: var(--bar-background-active);\n}\n\n.range-pin {\n  transform: translate3d(0,  100%,  0) scale(0.01);\n  -webkit-padding-start: 8px;\n  padding-inline-start: 8px;\n  -webkit-padding-end: 8px;\n  padding-inline-end: 8px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  min-width: 28px;\n  transition: transform 120ms ease;\n  background: transparent;\n  color: var(--ion-text-color, #000);\n  font-size: 0.75rem;\n  text-align: center;\n}\n\n/**\n * The -100% ensures the pin sits on top\n * of the range-knob-handle container.\n * We apply 11px so that the pin\n * text is closer to the knob inside of the container.\n * We also apply the 11px here instead of using \"top\"\n * otherwise the pin text will translate below the knob\n * when the text is scaled.\n */\n.range-knob-pressed .range-pin,\n.range-knob-handle.ion-focused .range-pin {\n  transform: translate3d(0, calc(-100% + 11px), 0) scale(1);\n}\n\n:host(.range-disabled) {\n  opacity: 0.3;\n}","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --bar-background: Background of the range bar\n   * @prop --bar-background-active: Background of the active range bar\n   * @prop --bar-height: Height of the range bar\n   * @prop --bar-border-radius: Border radius of the range bar\n   * @prop --height: Height of the range\n   * @prop --knob-background: Background of the range knob\n   * @prop --knob-border-radius: Border radius of the range knob\n   * @prop --knob-box-shadow: Box shadow of the range knob\n   * @prop --knob-size: Size of the range knob\n   * @prop --pin-background: Background of the range pin (only available in MD mode)\n   * @prop --pin-color: Color of the range pin (only available in MD mode)\n   */\n  --knob-handle-size: calc(var(--knob-size) * 2);\n  display: flex;\n  position: relative;\n  flex: 3;\n  align-items: center;\n  font-family: var(--ion-font-family, inherit);\n  user-select: none;\n  z-index: 2;\n}\n\n:host(.range-disabled) {\n  pointer-events: none;\n}\n\n::slotted(ion-label) {\n  flex: initial;\n}\n\n::slotted(ion-icon[slot]) {\n  font-size: 24px;\n}\n\n.range-slider {\n  position: relative;\n  flex: 1;\n  width: 100%;\n  height: var(--height);\n  contain: size layout style;\n  cursor: grab;\n  touch-action: pan-y;\n}\n\n:host(.range-pressed) .range-slider {\n  cursor: grabbing;\n}\n\n.range-pin {\n  position: absolute;\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n  text-align: center;\n  box-sizing: border-box;\n}\n\n.range-knob-handle {\n  top: calc((var(--height) - var(--knob-handle-size)) / 2);\n  -webkit-margin-start: calc(0px - var(--knob-handle-size) / 2);\n  margin-inline-start: calc(0px - var(--knob-handle-size) / 2);\n  display: flex;\n  position: absolute;\n  justify-content: center;\n  width: var(--knob-handle-size);\n  height: var(--knob-handle-size);\n  text-align: center;\n}\n@supports (inset-inline-start: 0) {\n  .range-knob-handle {\n    inset-inline-start: 0;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .range-knob-handle {\n    left: 0;\n  }\n  :host-context([dir=rtl]) .range-knob-handle {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  [dir=rtl] .range-knob-handle {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  @supports selector(:dir(rtl)) {\n    .range-knob-handle:dir(rtl) {\n      left: unset;\n      right: unset;\n      right: 0;\n    }\n  }\n}\n:host-context([dir=rtl]) .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-knob-handle:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n.range-knob-handle:active, .range-knob-handle:focus {\n  outline: none;\n}\n\n.range-bar-container {\n  border-radius: var(--bar-border-radius);\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n}\n@supports (inset-inline-start: 0) {\n  .range-bar-container {\n    inset-inline-start: 0;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .range-bar-container {\n    left: 0;\n  }\n  :host-context([dir=rtl]) .range-bar-container {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  [dir=rtl] .range-bar-container {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  @supports selector(:dir(rtl)) {\n    .range-bar-container:dir(rtl) {\n      left: unset;\n      right: unset;\n      right: 0;\n    }\n  }\n}\n:host-context([dir=rtl]) .range-bar-container {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-bar-container {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-bar-container:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n.range-bar {\n  border-radius: var(--bar-border-radius);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n  background: var(--bar-background);\n  pointer-events: none;\n}\n\n.range-knob {\n  border-radius: var(--knob-border-radius);\n  top: calc(50% - var(--knob-size) / 2);\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  background: var(--knob-background);\n  box-shadow: var(--knob-box-shadow);\n  z-index: 2;\n  pointer-events: none;\n}\n@supports (inset-inline-start: 0) {\n  .range-knob {\n    inset-inline-start: calc(50% - var(--knob-size) / 2);\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .range-knob {\n    left: calc(50% - var(--knob-size) / 2);\n  }\n  :host-context([dir=rtl]) .range-knob {\n    left: unset;\n    right: unset;\n    right: calc(50% - var(--knob-size) / 2);\n  }\n  [dir=rtl] .range-knob {\n    left: unset;\n    right: unset;\n    right: calc(50% - var(--knob-size) / 2);\n  }\n  @supports selector(:dir(rtl)) {\n    .range-knob:dir(rtl) {\n      left: unset;\n      right: unset;\n      right: calc(50% - var(--knob-size) / 2);\n    }\n  }\n}\n:host-context([dir=rtl]) .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-knob:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n:host(.range-pressed) .range-bar-active {\n  will-change: left, right;\n}\n\n:host(.in-item) {\n  width: 100%;\n}\n\n/**\n * Range can be slotted\n * in components such as item and\n * toolbar which is why we do not\n * limit the below behavior to just ion-item.\n */\n:host([slot=start]),\n:host([slot=end]) {\n  width: auto;\n}\n\n:host(.in-item) ::slotted(ion-label) {\n  align-self: center;\n}\n\n.range-wrapper {\n  display: flex;\n  position: relative;\n  flex-grow: 1;\n  align-items: center;\n  height: inherit;\n}\n\n::slotted([slot=label]) {\n  /**\n   * Label text should not extend\n   * beyond the bounds of the range.\n   * However, we do not set the max\n   * width to 100% because then\n   * only the label would show and users\n   * would not be able to see the range.\n   */\n  max-width: 200px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n\n/**\n * If no label text is placed into the slot\n * then the element should be hidden otherwise\n * there will be additional margins added.\n */\n.label-text-wrapper-hidden {\n  display: none;\n}\n\n.native-wrapper {\n  display: flex;\n  flex-grow: 1;\n  align-items: center;\n}\n\n/**\n * Label is on the left of the range in LTR and\n * on the right in RTL.\n */\n:host(.range-label-placement-start) .range-wrapper {\n  flex-direction: row;\n}\n\n:host(.range-label-placement-start) .label-text-wrapper {\n  /**\n   * The margin between the label and\n   * the range should be on the end\n   * when the label sits at the start.\n   */\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n/**\n * Label is on the right of the range in LTR and\n * on the left in RTL.\n */\n:host(.range-label-placement-end) .range-wrapper {\n  flex-direction: row-reverse;\n}\n\n/**\n * The margin between the label and\n * the range should be on the start\n * when the label sits at the end.\n */\n:host(.range-label-placement-end) .label-text-wrapper {\n  -webkit-margin-start: 16px;\n  margin-inline-start: 16px;\n  -webkit-margin-end: 0;\n  margin-inline-end: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n:host(.range-label-placement-fixed) .label-text-wrapper {\n  /**\n   * The margin between the label and\n   * the range should be on the end\n   * when the label sits at the start.\n   */\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n/**\n * Label is on the left of the range in LTR and\n * on the right in RTL. Label also has a fixed width.\n */\n:host(.range-label-placement-fixed) .label-text-wrapper {\n  flex: 0 0 100px;\n  width: 100px;\n  min-width: 100px;\n  max-width: 200px;\n}\n\n/**\n * Label is on top of the range.\n */\n:host(.range-label-placement-stacked) .range-wrapper {\n  flex-direction: column;\n  align-items: stretch;\n}\n\n:host(.range-label-placement-stacked) .label-text-wrapper {\n  transform-origin: left top;\n  transform: scale(0.75);\n  /**\n  * The margin between the label and\n  * the range should be on the bottom\n  * when the label sits on top.\n  */\n  margin-left: 0;\n  margin-right: 0;\n  margin-bottom: 16px;\n  /**\n   * Label text should not extend\n   * beyond the bounds of the range.\n   */\n  max-width: calc(100% / 0.75);\n}\n:host-context([dir=rtl]):host(.range-label-placement-stacked) .label-text-wrapper, :host-context([dir=rtl]).range-label-placement-stacked .label-text-wrapper {\n  transform-origin: right top;\n}\n\n@supports selector(:dir(rtl)) {\n  :host(.range-label-placement-stacked:dir(rtl)) .label-text-wrapper {\n    transform-origin: right top;\n  }\n}\n\n:host(.in-item.range-label-placement-stacked) .label-text-wrapper {\n  margin-top: 10px;\n  margin-bottom: 16px;\n}\n\n:host(.in-item.range-label-placement-stacked) .native-wrapper {\n  margin-bottom: 0px;\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n/**\n * 18px was chosen so the knob and its focus/active\n * effects do not get cut off by the item.\n */\n:host {\n  --knob-border-radius: 50%;\n  --knob-background: var(--bar-background-active);\n  --knob-box-shadow: none;\n  --knob-size: 18px;\n  --bar-height: 2px;\n  --bar-background: rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.26);\n  --bar-background-active: var(--ion-color-primary, #3880ff);\n  --bar-border-radius: 0;\n  --height: 42px;\n  --pin-background: var(--ion-color-primary, #3880ff);\n  --pin-color: var(--ion-color-primary-contrast, #fff);\n}\n\n:host(.legacy-range) ::slotted([slot=label]) {\n  font-size: initial;\n}\n\n:host(:not(.legacy-range)) ::slotted(:not(ion-icon)[slot=start]),\n:host(:not(.legacy-range)) ::slotted(:not(ion-icon)[slot=end]),\n:host(:not(.legacy-range)) .native-wrapper {\n  font-size: 0.75rem;\n}\n\n:host(.legacy-range) {\n  -webkit-padding-start: 14px;\n  padding-inline-start: 14px;\n  -webkit-padding-end: 14px;\n  padding-inline-end: 14px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  font-size: 0.75rem;\n}\n\n:host(.range-item-start-adjustment) {\n  -webkit-padding-start: 18px;\n  padding-inline-start: 18px;\n}\n\n:host(.range-item-end-adjustment) {\n  -webkit-padding-end: 18px;\n  padding-inline-end: 18px;\n}\n\n:host(.ion-color) .range-bar {\n  background: rgba(var(--ion-color-base-rgb), 0.26);\n}\n\n:host(.ion-color) .range-bar-active,\n:host(.ion-color) .range-knob,\n:host(.ion-color) .range-knob::before,\n:host(.ion-color) .range-pin,\n:host(.ion-color) .range-pin::before,\n:host(.ion-color) .range-tick {\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n}\n\n::slotted([slot=start]) {\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 14px;\n  margin-inline-end: 14px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n::slotted([slot=end]) {\n  -webkit-margin-start: 14px;\n  margin-inline-start: 14px;\n  -webkit-margin-end: 0;\n  margin-inline-end: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n:host(.range-has-pin:not(.range-label-placement-stacked)) {\n  /**\n  * The pin should not overlap any elements that are\n  * above the range. By adding padding to the top of the\n  * range, it provides a buffer for the pin to move into\n  * when it is pressed.\n  *\n  * The padding is not included when the label is stacked\n  * because the pin is below the label.\n  * It still requires a buffer to prevent the pin from\n  * overlapping the range. The buffer is added to the\n  * bottom of the range label instead of the host.\n  */\n  padding-top: 1.75rem;\n}\n\n:host(.range-has-pin.range-label-placement-stacked) .label-text-wrapper {\n  /**\n  * The pin should not overlap the stacked label. By adding\n  * margin to the bottom of the label, it provides a buffer\n  * for the pin to move into when it is pressed.\n  */\n  margin-bottom: 1.75rem;\n}\n\n.range-bar-active {\n  bottom: 0;\n  width: auto;\n  background: var(--bar-background-active);\n}\n\n.range-knob {\n  transform: scale(0.67);\n  transition-duration: 120ms;\n  transition-property: transform, background-color, border;\n  transition-timing-function: ease;\n  z-index: 2;\n}\n.range-knob::before {\n  border-radius: 50%;\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  transform: scale(1);\n  transition: 0.267s cubic-bezier(0, 0, 0.58, 1);\n  background: var(--knob-background);\n  content: \"\";\n  opacity: 0.13;\n  pointer-events: none;\n}\n@supports (inset-inline-start: 0) {\n  .range-knob::before {\n    inset-inline-start: 0;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .range-knob::before {\n    left: 0;\n  }\n  :host-context([dir=rtl]) .range-knob::before {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  [dir=rtl] .range-knob::before {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  @supports selector(:dir(rtl)) {\n    .range-knob::before:dir(rtl) {\n      left: unset;\n      right: unset;\n      right: 0;\n    }\n  }\n}\n\n.range-tick {\n  position: absolute;\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  width: var(--bar-height);\n  height: var(--bar-height);\n  background: var(--bar-background-active);\n  z-index: 1;\n  pointer-events: none;\n}\n\n.range-tick-active {\n  background: transparent;\n}\n\n.range-pin {\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  border-radius: 50%;\n  transform: translate3d(0,  0,  0) scale(0.01);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  /**\n   * The dimensions of the range need\n   * to scale with the size of the text\n   * which is why we use dynamic dimensions here.\n   */\n  width: 1.75rem;\n  height: 1.75rem;\n  transition: transform 120ms ease, background 120ms ease;\n  background: var(--pin-background);\n  color: var(--pin-color);\n}\n.range-pin::before {\n  /**\n   * The -1px here moves the ::before\n   * psuedo-element down to create a uniform pin shape.\n   */\n  bottom: -1px;\n  -webkit-margin-start: -13px;\n  margin-inline-start: -13px;\n  /* stylelint-disable-next-line property-disallowed-list */\n  border-radius: 50% 50% 50% 0;\n  position: absolute;\n  width: 26px;\n  height: 26px;\n  transform: rotate(-45deg);\n  transition: background 120ms ease;\n  background: var(--pin-background);\n  content: \"\";\n  z-index: -1;\n}\n@supports (inset-inline-start: 0) {\n  .range-pin::before {\n    inset-inline-start: 50%;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .range-pin::before {\n    left: 50%;\n  }\n  :host-context([dir=rtl]) .range-pin::before {\n    left: unset;\n    right: unset;\n    right: 50%;\n  }\n  [dir=rtl] .range-pin::before {\n    left: unset;\n    right: unset;\n    right: 50%;\n  }\n  @supports selector(:dir(rtl)) {\n    .range-pin::before:dir(rtl) {\n      left: unset;\n      right: unset;\n      right: 50%;\n    }\n  }\n}\n:host-context([dir=rtl]) .range-pin::before {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-pin::before {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-pin::before:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n/**\n * Move the pin up by its full height\n * plus a few pixels so the tip is above\n * (but not touching) the knob.\n */\n.range-knob-pressed .range-pin,\n.range-knob-handle.ion-focused .range-pin {\n  transform: translate3d(0, calc(-100% + 4px), 0) scale(1);\n}\n\n@media (any-hover: hover) {\n  .range-knob-handle:hover .range-knob:before {\n    transform: scale(2);\n    opacity: 0.13;\n  }\n}\n.range-knob-handle.ion-activated .range-knob:before, .range-knob-handle.ion-focused .range-knob:before, .range-knob-handle.range-knob-pressed .range-knob:before {\n  transform: scale(2);\n}\n.range-knob-handle.ion-focused .range-knob::before {\n  opacity: 0.13;\n}\n.range-knob-handle.ion-activated .range-knob::before, .range-knob-handle.range-knob-pressed .range-knob::before {\n  opacity: 0.25;\n}\n\n:host(:not(.range-has-pin)) .range-knob-pressed .range-knob,\n:host(:not(.range-has-pin)) .range-knob-handle.ion-focused .range-knob {\n  transform: scale(1);\n}\n\n:host(.range-disabled) .range-bar-active,\n:host(.range-disabled) .range-bar,\n:host(.range-disabled) .range-tick {\n  background-color: var(--ion-color-step-250, #bfbfbf);\n}\n\n:host(.range-disabled) .range-knob {\n  transform: scale(0.55);\n  outline: 5px solid #fff;\n  background-color: var(--ion-color-step-250, #bfbfbf);\n}\n\n:host(.range-disabled) .label-text-wrapper,\n:host(.range-disabled) ::slotted([slot=start]),\n:host(.range-disabled) ::slotted([slot=end]) {\n  opacity: 0.38;\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from \"@stencil/core\";\nimport { findClosestIonContent, disableContentScrollY, resetContentScrollY } from \"../../utils/content/index\";\nimport { createLegacyFormController } from \"../../utils/forms/index\";\nimport { inheritAriaAttributes, clamp, debounceEvent, getAriaLabel, renderHiddenInput } from \"../../utils/helpers\";\nimport { printIonWarning } from \"../../utils/logging/index\";\nimport { isRTL } from \"../../utils/rtl/index\";\nimport { createColorClasses, hostContext } from \"../../utils/theme\";\nimport { getIonMode } from \"../../global/ionic-global\";\nimport { roundToMaxDecimalPlaces } from \"../../utils/floating-point\";\n// TODO(FW-2832): types\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n *\n * @slot label - The label text to associate with the range. Use the \"labelPlacement\" property to control where the label is placed relative to the range.\n * @slot start - Content is placed to the left of the range slider in LTR, and to the right in RTL.\n * @slot end - Content is placed to the right of the range slider in LTR, and to the left in RTL.\n *\n * @part tick - An inactive tick mark.\n * @part tick-active - An active tick mark.\n * @part pin - The counter that appears above a knob.\n * @part knob - The handle that is used to drag the range.\n * @part bar - The inactive part of the bar.\n * @part bar-active - The active part of the bar.\n * @part label - The label text describing the range.\n */\nexport class Range {\n    constructor() {\n        this.rangeId = `ion-r-${rangeIds++}`;\n        this.didLoad = false;\n        this.noUpdate = false;\n        this.hasFocus = false;\n        this.inheritedAttributes = {};\n        this.contentEl = null;\n        this.initialContentScrollY = true;\n        // This flag ensures we log the deprecation warning at most once.\n        this.hasLoggedDeprecationWarning = false;\n        this.clampBounds = (value) => {\n            return clamp(this.min, value, this.max);\n        };\n        this.ensureValueInBounds = (value) => {\n            if (this.dualKnobs) {\n                return {\n                    lower: this.clampBounds(value.lower),\n                    upper: this.clampBounds(value.upper),\n                };\n            }\n            else {\n                return this.clampBounds(value);\n            }\n        };\n        this.setupGesture = async () => {\n            const rangeSlider = this.rangeSlider;\n            if (rangeSlider) {\n                this.gesture = (await import('../../utils/gesture')).createGesture({\n                    el: rangeSlider,\n                    gestureName: 'range',\n                    gesturePriority: 100,\n                    /**\n                     * Provide a threshold since the drag movement\n                     * might be a user scrolling the view.\n                     * If this is true, then the range\n                     * should not move.\n                     */\n                    threshold: 10,\n                    onStart: () => this.onStart(),\n                    onMove: (ev) => this.onMove(ev),\n                    onEnd: (ev) => this.onEnd(ev),\n                });\n                this.gesture.enable(!this.disabled);\n            }\n        };\n        this.handleKeyboard = (knob, isIncrease) => {\n            const { ensureValueInBounds } = this;\n            let step = this.step;\n            step = step > 0 ? step : 1;\n            step = step / (this.max - this.min);\n            if (!isIncrease) {\n                step *= -1;\n            }\n            if (knob === 'A') {\n                this.ratioA = clamp(0, this.ratioA + step, 1);\n            }\n            else {\n                this.ratioB = clamp(0, this.ratioB + step, 1);\n            }\n            this.ionKnobMoveStart.emit({ value: ensureValueInBounds(this.value) });\n            this.updateValue();\n            this.emitValueChange();\n            this.ionKnobMoveEnd.emit({ value: ensureValueInBounds(this.value) });\n        };\n        this.onBlur = () => {\n            if (this.hasFocus) {\n                this.hasFocus = false;\n                this.ionBlur.emit();\n                this.emitStyle();\n            }\n        };\n        this.onFocus = () => {\n            if (!this.hasFocus) {\n                this.hasFocus = true;\n                this.ionFocus.emit();\n                this.emitStyle();\n            }\n        };\n        this.ratioA = 0;\n        this.ratioB = 0;\n        this.pressedKnob = undefined;\n        this.color = undefined;\n        this.debounce = undefined;\n        this.name = this.rangeId;\n        this.label = undefined;\n        this.dualKnobs = false;\n        this.min = 0;\n        this.max = 100;\n        this.pin = false;\n        this.pinFormatter = (value) => Math.round(value);\n        this.snaps = false;\n        this.step = 1;\n        this.ticks = true;\n        this.activeBarStart = undefined;\n        this.disabled = false;\n        this.value = 0;\n        this.labelPlacement = 'start';\n        this.legacy = undefined;\n    }\n    debounceChanged() {\n        const { ionInput, debounce, originalIonInput } = this;\n        /**\n         * If debounce is undefined, we have to manually revert the ionInput emitter in case\n         * debounce used to be set to a number. Otherwise, the event would stay debounced.\n         */\n        this.ionInput = debounce === undefined ? originalIonInput !== null && originalIonInput !== void 0 ? originalIonInput : ionInput : debounceEvent(ionInput, debounce);\n    }\n    minChanged() {\n        if (!this.noUpdate) {\n            this.updateRatio();\n        }\n    }\n    maxChanged() {\n        if (!this.noUpdate) {\n            this.updateRatio();\n        }\n    }\n    activeBarStartChanged() {\n        const { activeBarStart } = this;\n        if (activeBarStart !== undefined) {\n            if (activeBarStart > this.max) {\n                printIonWarning(`Range: The value of activeBarStart (${activeBarStart}) is greater than the max (${this.max}). Valid values are greater than or equal to the min value and less than or equal to the max value.`, this.el);\n                this.activeBarStart = this.max;\n            }\n            else if (activeBarStart < this.min) {\n                printIonWarning(`Range: The value of activeBarStart (${activeBarStart}) is less than the min (${this.min}). Valid values are greater than or equal to the min value and less than or equal to the max value.`, this.el);\n                this.activeBarStart = this.min;\n            }\n        }\n    }\n    disabledChanged() {\n        if (this.gesture) {\n            this.gesture.enable(!this.disabled);\n        }\n        this.emitStyle();\n    }\n    valueChanged() {\n        if (!this.noUpdate) {\n            this.updateRatio();\n        }\n    }\n    componentWillLoad() {\n        /**\n         * If user has custom ID set then we should\n         * not assign the default incrementing ID.\n         */\n        if (this.el.hasAttribute('id')) {\n            this.rangeId = this.el.getAttribute('id');\n        }\n        this.inheritedAttributes = inheritAriaAttributes(this.el);\n    }\n    componentDidLoad() {\n        this.originalIonInput = this.ionInput;\n        this.setupGesture();\n        this.updateRatio();\n        this.didLoad = true;\n    }\n    connectedCallback() {\n        const { el } = this;\n        this.legacyFormController = createLegacyFormController(el);\n        this.updateRatio();\n        this.debounceChanged();\n        this.disabledChanged();\n        this.activeBarStartChanged();\n        /**\n         * If we have not yet rendered\n         * ion-range, then rangeSlider is not defined.\n         * But if we are moving ion-range via appendChild,\n         * then rangeSlider will be defined.\n         */\n        if (this.didLoad) {\n            this.setupGesture();\n        }\n        this.contentEl = findClosestIonContent(this.el);\n    }\n    disconnectedCallback() {\n        if (this.gesture) {\n            this.gesture.destroy();\n            this.gesture = undefined;\n        }\n    }\n    getValue() {\n        var _a;\n        const value = (_a = this.value) !== null && _a !== void 0 ? _a : 0;\n        if (this.dualKnobs) {\n            if (typeof value === 'object') {\n                return value;\n            }\n            return {\n                lower: 0,\n                upper: value,\n            };\n        }\n        else {\n            if (typeof value === 'object') {\n                return value.upper;\n            }\n            return value;\n        }\n    }\n    // TODO FW-2997 remove this\n    emitStyle() {\n        if (this.legacyFormController.hasLegacyControl()) {\n            this.ionStyle.emit({\n                interactive: true,\n                'interactive-disabled': this.disabled,\n                // TODO(FW-2997): remove this\n                legacy: !!this.legacy,\n            });\n        }\n    }\n    /**\n     * Emits an `ionChange` event.\n     *\n     * This API should be called for user committed changes.\n     * This API should not be used for external value changes.\n     */\n    emitValueChange() {\n        this.value = this.ensureValueInBounds(this.value);\n        this.ionChange.emit({ value: this.value });\n    }\n    /**\n     * The value should be updated on touch end or\n     * when the component is being dragged.\n     * This follows the native behavior of mobile devices.\n     *\n     * For example: When the user lifts their finger from the\n     * screen after tapping the bar or dragging the bar or knob.\n     */\n    onStart() {\n        this.ionKnobMoveStart.emit({ value: this.ensureValueInBounds(this.value) });\n    }\n    /**\n     * The value should be updated while dragging the\n     * bar or knob.\n     *\n     * While the user is dragging, the view\n     * should not scroll. This is to prevent the user from\n     * feeling disoriented while dragging.\n     *\n     * The user can scroll on the view if the knob or\n     * bar is not being dragged.\n     *\n     * @param detail The details of the gesture event.\n     */\n    onMove(detail) {\n        const { contentEl, pressedKnob } = this;\n        const currentX = detail.currentX;\n        /**\n         * Since the user is dragging on the bar or knob, the view should not scroll.\n         *\n         * This only needs to be done once.\n         */\n        if (contentEl && this.initialContentScrollY === undefined) {\n            this.initialContentScrollY = disableContentScrollY(contentEl);\n        }\n        /**\n         * The `pressedKnob` can be undefined if the user just\n         * started dragging the knob.\n         *\n         * This is necessary to determine which knob the user is dragging,\n         * especially when it's a dual knob.\n         * Plus, it determines when to apply certain styles.\n         *\n         * This only needs to be done once since the knob won't change\n         * while the user is dragging.\n         */\n        if (pressedKnob === undefined) {\n            this.setPressedKnob(currentX);\n        }\n        this.update(currentX);\n    }\n    /**\n     * The value should be updated on touch end:\n     * - When the user lifts their finger from the screen after\n     * tapping the bar.\n     *\n     * @param detail The details of the gesture or mouse event.\n     */\n    onEnd(detail) {\n        const { contentEl, initialContentScrollY } = this;\n        const currentX = detail.currentX || detail.clientX;\n        /**\n         * The `pressedKnob` can be undefined if the user never\n         * dragged the knob. They just tapped on the bar.\n         *\n         * This is necessary to determine which knob the user is changing,\n         * especially when it's a dual knob.\n         * Plus, it determines when to apply certain styles.\n         */\n        if (this.pressedKnob === undefined) {\n            this.setPressedKnob(currentX);\n        }\n        /**\n         * The user is no longer dragging the bar or\n         * knob (if they were dragging it).\n         *\n         * The user can now scroll on the view in the next gesture event.\n         */\n        if (contentEl && initialContentScrollY !== undefined) {\n            resetContentScrollY(contentEl, initialContentScrollY);\n        }\n        // update the active knob's position\n        this.update(currentX);\n        /**\n         * Reset the pressed knob to undefined since the user\n         * may start dragging a different knob in the next gesture event.\n         */\n        this.pressedKnob = undefined;\n        this.emitValueChange();\n        this.ionKnobMoveEnd.emit({ value: this.ensureValueInBounds(this.value) });\n    }\n    update(currentX) {\n        // figure out where the pointer is currently at\n        // update the knob being interacted with\n        const rect = this.rect;\n        let ratio = clamp(0, (currentX - rect.left) / rect.width, 1);\n        if (isRTL(this.el)) {\n            ratio = 1 - ratio;\n        }\n        if (this.snaps) {\n            // snaps the ratio to the current value\n            ratio = valueToRatio(ratioToValue(ratio, this.min, this.max, this.step), this.min, this.max);\n        }\n        // update which knob is pressed\n        if (this.pressedKnob === 'A') {\n            this.ratioA = ratio;\n        }\n        else {\n            this.ratioB = ratio;\n        }\n        // Update input value\n        this.updateValue();\n    }\n    setPressedKnob(currentX) {\n        const rect = (this.rect = this.rangeSlider.getBoundingClientRect());\n        // figure out which knob they started closer to\n        let ratio = clamp(0, (currentX - rect.left) / rect.width, 1);\n        if (isRTL(this.el)) {\n            ratio = 1 - ratio;\n        }\n        this.pressedKnob = !this.dualKnobs || Math.abs(this.ratioA - ratio) < Math.abs(this.ratioB - ratio) ? 'A' : 'B';\n        this.setFocus(this.pressedKnob);\n    }\n    get valA() {\n        return ratioToValue(this.ratioA, this.min, this.max, this.step);\n    }\n    get valB() {\n        return ratioToValue(this.ratioB, this.min, this.max, this.step);\n    }\n    get ratioLower() {\n        if (this.dualKnobs) {\n            return Math.min(this.ratioA, this.ratioB);\n        }\n        const { activeBarStart } = this;\n        if (activeBarStart == null) {\n            return 0;\n        }\n        return valueToRatio(activeBarStart, this.min, this.max);\n    }\n    get ratioUpper() {\n        if (this.dualKnobs) {\n            return Math.max(this.ratioA, this.ratioB);\n        }\n        return this.ratioA;\n    }\n    updateRatio() {\n        const value = this.getValue();\n        const { min, max } = this;\n        if (this.dualKnobs) {\n            this.ratioA = valueToRatio(value.lower, min, max);\n            this.ratioB = valueToRatio(value.upper, min, max);\n        }\n        else {\n            this.ratioA = valueToRatio(value, min, max);\n        }\n    }\n    updateValue() {\n        this.noUpdate = true;\n        const { valA, valB } = this;\n        this.value = !this.dualKnobs\n            ? valA\n            : {\n                lower: Math.min(valA, valB),\n                upper: Math.max(valA, valB),\n            };\n        this.ionInput.emit({ value: this.value });\n        this.noUpdate = false;\n    }\n    setFocus(knob) {\n        if (this.el.shadowRoot) {\n            const knobEl = this.el.shadowRoot.querySelector(knob === 'A' ? '.range-knob-a' : '.range-knob-b');\n            if (knobEl) {\n                knobEl.focus();\n            }\n        }\n    }\n    // TODO FW-2997 remove this\n    renderLegacyRange() {\n        if (!this.hasLoggedDeprecationWarning) {\n            printIonWarning(`ion-range now requires providing a label with either the label slot or the \"aria-label\" attribute. To migrate, remove any usage of \"ion-label\" and pass the label text to either the component or the \"aria-label\" attribute.\n\nExample: <ion-range><div slot=\"label\">Volume</div></ion-range>\nExample with aria-label: <ion-range aria-label=\"Volume\"></ion-range>\n\nDevelopers can use the \"legacy\" property to continue using the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.`, this.el);\n            if (this.legacy) {\n                printIonWarning(`ion-range is being used with the \"legacy\" property enabled which will forcibly enable the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.\n\nDevelopers can dismiss this warning by removing their usage of the \"legacy\" property and using the new range syntax.`, this.el);\n            }\n            this.hasLoggedDeprecationWarning = true;\n        }\n        const { el, pressedKnob, disabled, pin, rangeId } = this;\n        const mode = getIonMode(this);\n        renderHiddenInput(true, el, this.name, JSON.stringify(this.getValue()), disabled);\n        return (h(Host, { onFocusin: this.onFocus, onFocusout: this.onBlur, id: rangeId, class: createColorClasses(this.color, {\n                [mode]: true,\n                'in-item': hostContext('ion-item', el),\n                'range-disabled': disabled,\n                'range-pressed': pressedKnob !== undefined,\n                'range-has-pin': pin,\n                'legacy-range': true,\n            }) }, h(\"slot\", { name: \"start\" }), this.renderRangeSlider(), h(\"slot\", { name: \"end\" })));\n    }\n    /**\n     * Returns true if content was passed to the \"start\" slot\n     */\n    get hasStartSlotContent() {\n        return this.el.querySelector('[slot=\"start\"]') !== null;\n    }\n    /**\n     * Returns true if content was passed to the \"end\" slot\n     */\n    get hasEndSlotContent() {\n        return this.el.querySelector('[slot=\"end\"]') !== null;\n    }\n    renderRange() {\n        const { disabled, el, hasLabel, rangeId, pin, pressedKnob, labelPlacement, label } = this;\n        const inItem = hostContext('ion-item', el);\n        /**\n         * If there is no start content then the knob at\n         * the min value will be cut off by the item margin.\n         */\n        const hasStartContent = (hasLabel && (labelPlacement === 'start' || labelPlacement === 'fixed')) || this.hasStartSlotContent;\n        const needsStartAdjustment = inItem && !hasStartContent;\n        /**\n         * If there is no end content then the knob at\n         * the max value will be cut off by the item margin.\n         */\n        const hasEndContent = (hasLabel && labelPlacement === 'end') || this.hasEndSlotContent;\n        const needsEndAdjustment = inItem && !hasEndContent;\n        const mode = getIonMode(this);\n        renderHiddenInput(true, el, this.name, JSON.stringify(this.getValue()), disabled);\n        return (h(Host, { onFocusin: this.onFocus, onFocusout: this.onBlur, id: rangeId, class: createColorClasses(this.color, {\n                [mode]: true,\n                'in-item': inItem,\n                'range-disabled': disabled,\n                'range-pressed': pressedKnob !== undefined,\n                'range-has-pin': pin,\n                [`range-label-placement-${labelPlacement}`]: true,\n                'range-item-start-adjustment': needsStartAdjustment,\n                'range-item-end-adjustment': needsEndAdjustment,\n            }) }, h(\"label\", { class: \"range-wrapper\", id: \"range-label\" }, h(\"div\", { class: {\n                'label-text-wrapper': true,\n                'label-text-wrapper-hidden': !hasLabel,\n            }, part: \"label\" }, label !== undefined ? h(\"div\", { class: \"label-text\" }, label) : h(\"slot\", { name: \"label\" })), h(\"div\", { class: \"native-wrapper\" }, h(\"slot\", { name: \"start\" }), this.renderRangeSlider(), h(\"slot\", { name: \"end\" })))));\n    }\n    get hasLabel() {\n        return this.label !== undefined || this.el.querySelector('[slot=\"label\"]') !== null;\n    }\n    renderRangeSlider() {\n        var _a;\n        const { min, max, step, el, handleKeyboard, pressedKnob, disabled, pin, ratioLower, ratioUpper, inheritedAttributes, rangeId, pinFormatter, } = this;\n        /**\n         * Look for external label, ion-label, or aria-labelledby.\n         * If none, see if user placed an aria-label on the host\n         * and use that instead.\n         */\n        let { labelText } = getAriaLabel(el, rangeId);\n        if (labelText === undefined || labelText === null) {\n            labelText = inheritedAttributes['aria-label'];\n        }\n        let barStart = `${ratioLower * 100}%`;\n        let barEnd = `${100 - ratioUpper * 100}%`;\n        const rtl = isRTL(this.el);\n        const start = rtl ? 'right' : 'left';\n        const end = rtl ? 'left' : 'right';\n        const tickStyle = (tick) => {\n            return {\n                [start]: tick[start],\n            };\n        };\n        if (this.dualKnobs === false) {\n            /**\n             * When the value is less than the activeBarStart or the min value,\n             * the knob will display at the start of the active bar.\n             */\n            if (this.valA < ((_a = this.activeBarStart) !== null && _a !== void 0 ? _a : this.min)) {\n                /**\n                 * Sets the bar positions relative to the upper and lower limits.\n                 * Converts the ratio values into percentages, used as offsets for left/right styles.\n                 *\n                 * The ratioUpper refers to the knob position on the bar.\n                 * The ratioLower refers to the end position of the active bar (the value).\n                 */\n                barStart = `${ratioUpper * 100}%`;\n                barEnd = `${100 - ratioLower * 100}%`;\n            }\n            else {\n                /**\n                 * Otherwise, the knob will display at the end of the active bar.\n                 *\n                 * The ratioLower refers to the start position of the active bar (the value).\n                 * The ratioUpper refers to the knob position on the bar.\n                 */\n                barStart = `${ratioLower * 100}%`;\n                barEnd = `${100 - ratioUpper * 100}%`;\n            }\n        }\n        const barStyle = {\n            [start]: barStart,\n            [end]: barEnd,\n        };\n        const ticks = [];\n        if (this.snaps && this.ticks) {\n            for (let value = min; value <= max; value += step) {\n                const ratio = valueToRatio(value, min, max);\n                const ratioMin = Math.min(ratioLower, ratioUpper);\n                const ratioMax = Math.max(ratioLower, ratioUpper);\n                const tick = {\n                    ratio,\n                    /**\n                     * Sets the tick mark as active when the tick is between the min bounds and the knob.\n                     * When using activeBarStart, the tick mark will be active between the knob and activeBarStart.\n                     */\n                    active: ratio >= ratioMin && ratio <= ratioMax,\n                };\n                tick[start] = `${ratio * 100}%`;\n                ticks.push(tick);\n            }\n        }\n        let labelledBy;\n        if (!this.legacyFormController.hasLegacyControl() && this.hasLabel) {\n            labelledBy = 'range-label';\n        }\n        return (h(\"div\", { class: \"range-slider\", ref: (rangeEl) => (this.rangeSlider = rangeEl),\n            /**\n             * Since the gesture has a threshold, the value\n             * won't change until the user has dragged past\n             * the threshold. This is to prevent the range\n             * from moving when the user is scrolling.\n             *\n             * This results in the value not being updated\n             * and the event emitters not being triggered\n             * if the user taps on the range. This is why\n             * we need to listen for the \"pointerUp\" event.\n             */\n            onPointerUp: (ev) => {\n                /**\n                 * If the user drags the knob on the web\n                 * version (does not occur on mobile),\n                 * the \"pointerUp\" event will be triggered\n                 * along with the gesture's events.\n                 * This leads to duplicate events.\n                 *\n                 * By checking if the pressedKnob is undefined,\n                 * we can determine if the \"pointerUp\" event was\n                 * triggered by a tap or a drag. If it was\n                 * dragged, the pressedKnob will be defined.\n                 */\n                if (this.pressedKnob === undefined) {\n                    this.onStart();\n                    this.onEnd(ev);\n                }\n            } }, ticks.map((tick) => (h(\"div\", { style: tickStyle(tick), role: \"presentation\", class: {\n                'range-tick': true,\n                'range-tick-active': tick.active,\n            }, part: tick.active ? 'tick-active' : 'tick' }))), h(\"div\", { class: \"range-bar-container\" }, h(\"div\", { class: \"range-bar\", role: \"presentation\", part: \"bar\" }), h(\"div\", { class: {\n                'range-bar': true,\n                'range-bar-active': true,\n                'has-ticks': ticks.length > 0,\n            }, role: \"presentation\", style: barStyle, part: \"bar-active\" })), renderKnob(rtl, {\n            knob: 'A',\n            pressed: pressedKnob === 'A',\n            value: this.valA,\n            ratio: this.ratioA,\n            pin,\n            pinFormatter,\n            disabled,\n            handleKeyboard,\n            min,\n            max,\n            labelText,\n            labelledBy,\n        }), this.dualKnobs &&\n            renderKnob(rtl, {\n                knob: 'B',\n                pressed: pressedKnob === 'B',\n                value: this.valB,\n                ratio: this.ratioB,\n                pin,\n                pinFormatter,\n                disabled,\n                handleKeyboard,\n                min,\n                max,\n                labelText,\n                labelledBy,\n            })));\n    }\n    render() {\n        const { legacyFormController } = this;\n        return legacyFormController.hasLegacyControl() ? this.renderLegacyRange() : this.renderRange();\n    }\n    static get is() { return \"ion-range\"; }\n    static get encapsulation() { return \"shadow\"; }\n    static get originalStyleUrls() {\n        return {\n            \"ios\": [\"range.ios.scss\"],\n            \"md\": [\"range.md.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"ios\": [\"range.ios.css\"],\n            \"md\": [\"range.md.css\"]\n        };\n    }\n    static get properties() {\n        return {\n            \"color\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"Color\",\n                    \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n                    \"references\": {\n                        \"Color\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::Color\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n                },\n                \"attribute\": \"color\",\n                \"reflect\": true\n            },\n            \"debounce\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"How long, in milliseconds, to wait to trigger the\\n`ionInput` event after each change in the range value.\"\n                },\n                \"attribute\": \"debounce\",\n                \"reflect\": false\n            },\n            \"name\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string\",\n                    \"resolved\": \"string\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The name of the control, which is submitted with the form data.\"\n                },\n                \"attribute\": \"name\",\n                \"reflect\": false,\n                \"defaultValue\": \"this.rangeId\"\n            },\n            \"label\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string\",\n                    \"resolved\": \"string | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The text to display as the control's label. Use this over the `label` slot if\\nyou only need plain text. The `label` property will take priority over the\\n`label` slot if both are used.\"\n                },\n                \"attribute\": \"label\",\n                \"reflect\": false\n            },\n            \"dualKnobs\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Show two knobs.\"\n                },\n                \"attribute\": \"dual-knobs\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"min\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Minimum integer value of the range.\"\n                },\n                \"attribute\": \"min\",\n                \"reflect\": false,\n                \"defaultValue\": \"0\"\n            },\n            \"max\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Maximum integer value of the range.\"\n                },\n                \"attribute\": \"max\",\n                \"reflect\": false,\n                \"defaultValue\": \"100\"\n            },\n            \"pin\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, a pin with integer value is shown when the knob\\nis pressed.\"\n                },\n                \"attribute\": \"pin\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"pinFormatter\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"PinFormatter\",\n                    \"resolved\": \"(value: number) => string | number\",\n                    \"references\": {\n                        \"PinFormatter\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::PinFormatter\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"A callback used to format the pin text.\\nBy default the pin text is set to `Math.round(value)`.\\n\\nSee https://ionicframework.com/docs/troubleshooting/runtime#accessing-this\\nif you need to access `this` from within the callback.\"\n                },\n                \"defaultValue\": \"(value: number): number => Math.round(value)\"\n            },\n            \"snaps\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the knob snaps to tick marks evenly spaced based\\non the step property value.\"\n                },\n                \"attribute\": \"snaps\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"step\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Specifies the value granularity.\"\n                },\n                \"attribute\": \"step\",\n                \"reflect\": false,\n                \"defaultValue\": \"1\"\n            },\n            \"ticks\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, tick marks are displayed based on the step value.\\nOnly applies when `snaps` is `true`.\"\n                },\n                \"attribute\": \"ticks\",\n                \"reflect\": false,\n                \"defaultValue\": \"true\"\n            },\n            \"activeBarStart\": {\n                \"type\": \"number\",\n                \"mutable\": true,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The start position of the range active bar. This feature is only available with a single knob (dualKnobs=\\\"false\\\").\\nValid values are greater than or equal to the min value and less than or equal to the max value.\"\n                },\n                \"attribute\": \"active-bar-start\",\n                \"reflect\": false\n            },\n            \"disabled\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the user cannot interact with the range.\"\n                },\n                \"attribute\": \"disabled\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"value\": {\n                \"type\": \"number\",\n                \"mutable\": true,\n                \"complexType\": {\n                    \"original\": \"RangeValue\",\n                    \"resolved\": \"number | { lower: number; upper: number; }\",\n                    \"references\": {\n                        \"RangeValue\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeValue\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"the value of the range.\"\n                },\n                \"attribute\": \"value\",\n                \"reflect\": false,\n                \"defaultValue\": \"0\"\n            },\n            \"labelPlacement\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"'start' | 'end' | 'fixed' | 'stacked'\",\n                    \"resolved\": \"\\\"end\\\" | \\\"fixed\\\" | \\\"stacked\\\" | \\\"start\\\"\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Where to place the label relative to the range.\\n`\\\"start\\\"`: The label will appear to the left of the range in LTR and to the right in RTL.\\n`\\\"end\\\"`: The label will appear to the right of the range in LTR and to the left in RTL.\\n`\\\"fixed\\\"`: The label has the same behavior as `\\\"start\\\"` except it also has a fixed width. Long text will be truncated with ellipses (\\\"...\\\").\\n`\\\"stacked\\\"`: The label will appear above the range regardless of the direction.\"\n                },\n                \"attribute\": \"label-placement\",\n                \"reflect\": false,\n                \"defaultValue\": \"'start'\"\n            },\n            \"legacy\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Set the `legacy` property to `true` to forcibly use the legacy form control markup.\\nIonic will only opt components in to the modern form markup when they are\\nusing either the `aria-label` attribute or the `label` property. As a result,\\nthe `legacy` property should only be used as an escape hatch when you want to\\navoid this automatic opt-in behavior.\\nNote that this property will be removed in an upcoming major release\\nof Ionic, and all form components will be opted-in to using the modern form markup.\"\n                },\n                \"attribute\": \"legacy\",\n                \"reflect\": false\n            }\n        };\n    }\n    static get states() {\n        return {\n            \"ratioA\": {},\n            \"ratioB\": {},\n            \"pressedKnob\": {}\n        };\n    }\n    static get events() {\n        return [{\n                \"method\": \"ionChange\",\n                \"name\": \"ionChange\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The `ionChange` event is fired for `<ion-range>` elements when the user\\nmodifies the element's value:\\n- When the user releases the knob after dragging;\\n- When the user moves the knob with keyboard arrows\\n\\n`ionChange` is not fired when the value is changed programmatically.\"\n                },\n                \"complexType\": {\n                    \"original\": \"RangeChangeEventDetail\",\n                    \"resolved\": \"RangeChangeEventDetail\",\n                    \"references\": {\n                        \"RangeChangeEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeChangeEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionInput\",\n                \"name\": \"ionInput\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The `ionInput` event is fired for `<ion-range>` elements when the value\\nis modified. Unlike `ionChange`, `ionInput` is fired continuously\\nwhile the user is dragging the knob.\"\n                },\n                \"complexType\": {\n                    \"original\": \"RangeChangeEventDetail\",\n                    \"resolved\": \"RangeChangeEventDetail\",\n                    \"references\": {\n                        \"RangeChangeEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeChangeEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionStyle\",\n                \"name\": \"ionStyle\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"Emitted when the styles change.\"\n                },\n                \"complexType\": {\n                    \"original\": \"StyleEventDetail\",\n                    \"resolved\": \"StyleEventDetail\",\n                    \"references\": {\n                        \"StyleEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::StyleEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionFocus\",\n                \"name\": \"ionFocus\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the range has focus.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"ionBlur\",\n                \"name\": \"ionBlur\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the range loses focus.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"ionKnobMoveStart\",\n                \"name\": \"ionKnobMoveStart\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the user starts moving the range knob, whether through\\nmouse drag, touch gesture, or keyboard interaction.\"\n                },\n                \"complexType\": {\n                    \"original\": \"RangeKnobMoveStartEventDetail\",\n                    \"resolved\": \"RangeKnobMoveStartEventDetail\",\n                    \"references\": {\n                        \"RangeKnobMoveStartEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeKnobMoveStartEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionKnobMoveEnd\",\n                \"name\": \"ionKnobMoveEnd\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the user finishes moving the range knob, whether through\\nmouse drag, touch gesture, or keyboard interaction.\"\n                },\n                \"complexType\": {\n                    \"original\": \"RangeKnobMoveEndEventDetail\",\n                    \"resolved\": \"RangeKnobMoveEndEventDetail\",\n                    \"references\": {\n                        \"RangeKnobMoveEndEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeKnobMoveEndEventDetail\"\n                        }\n                    }\n                }\n            }];\n    }\n    static get elementRef() { return \"el\"; }\n    static get watchers() {\n        return [{\n                \"propName\": \"debounce\",\n                \"methodName\": \"debounceChanged\"\n            }, {\n                \"propName\": \"min\",\n                \"methodName\": \"minChanged\"\n            }, {\n                \"propName\": \"max\",\n                \"methodName\": \"maxChanged\"\n            }, {\n                \"propName\": \"activeBarStart\",\n                \"methodName\": \"activeBarStartChanged\"\n            }, {\n                \"propName\": \"disabled\",\n                \"methodName\": \"disabledChanged\"\n            }, {\n                \"propName\": \"value\",\n                \"methodName\": \"valueChanged\"\n            }];\n    }\n}\nconst renderKnob = (rtl, { knob, value, ratio, min, max, disabled, pressed, pin, handleKeyboard, labelText, labelledBy, pinFormatter, }) => {\n    const start = rtl ? 'right' : 'left';\n    const knobStyle = () => {\n        const style = {};\n        style[start] = `${ratio * 100}%`;\n        return style;\n    };\n    return (h(\"div\", { onKeyDown: (ev) => {\n            const key = ev.key;\n            if (key === 'ArrowLeft' || key === 'ArrowDown') {\n                handleKeyboard(knob, false);\n                ev.preventDefault();\n                ev.stopPropagation();\n            }\n            else if (key === 'ArrowRight' || key === 'ArrowUp') {\n                handleKeyboard(knob, true);\n                ev.preventDefault();\n                ev.stopPropagation();\n            }\n        }, class: {\n            'range-knob-handle': true,\n            'range-knob-a': knob === 'A',\n            'range-knob-b': knob === 'B',\n            'range-knob-pressed': pressed,\n            'range-knob-min': value === min,\n            'range-knob-max': value === max,\n            'ion-activatable': true,\n            'ion-focusable': true,\n        }, style: knobStyle(), role: \"slider\", tabindex: disabled ? -1 : 0, \"aria-label\": labelledBy === undefined ? labelText : null, \"aria-labelledby\": labelledBy !== undefined ? labelledBy : null, \"aria-valuemin\": min, \"aria-valuemax\": max, \"aria-disabled\": disabled ? 'true' : null, \"aria-valuenow\": value }, pin && (h(\"div\", { class: \"range-pin\", role: \"presentation\", part: \"pin\" }, pinFormatter(value))), h(\"div\", { class: \"range-knob\", role: \"presentation\", part: \"knob\" })));\n};\nconst ratioToValue = (ratio, min, max, step) => {\n    let value = (max - min) * ratio;\n    if (step > 0) {\n        // round to nearest multiple of step, then add min\n        value = Math.round(value / step) * step + min;\n    }\n    const clampedValue = clamp(min, value, max);\n    return roundToMaxDecimalPlaces(clampedValue, min, max, step);\n};\nconst valueToRatio = (value, min, max) => {\n    return clamp(0, (value - min) / (max - min), 1);\n};\nlet rangeIds = 0;\n"],"mappings":"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","ignoreList":[]}
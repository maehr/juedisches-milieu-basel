{"version":3,"names":["getAnimationPosition","position","positionAnchor","mode","toast","offset","win","warnIfAnchorIsHidden","box","getBoundingClientRect","bottom","innerHeight","top","offsetParent","printIonWarning","getOffsetForMiddlePosition","toastHeight","wrapperHeight","Math","floor","iosEnterAnimation","baseEl","opts","baseAnimation","createAnimation","wrapperAnimation","root","getElementRoot","wrapperEl","querySelector","addElement","fromTo","topPosition","clientHeight","style","easing","duration","addAnimation","iosLeaveAnimation","mdEnterAnimation","setProperty","mdLeaveAnimation","createSwipeToDismissGesture","el","toastPosition","onDismiss","hostElHeight","wrapperElBox","MAX_SWIPE_DISTANCE","DISMISS_THRESHOLD","STEP_OFFSET","INVERSION_FACTOR","height","SWIPE_UP_DOWN_KEYFRAMES","transform","swipeAnimation","keyframes","progressStart","computeStep","delta","onMove","detail","step","deltaY","progressStep","onEnd","velocity","velocityY","threshold","gesture","enable","shouldDismiss","playTo","remainingDistance","startOffset","startPosition","offsetFactor","endOffset","endPosition","KEYFRAMES","remainingStepAmount","min","abs","onFinish","destroy","oneTimeCallback","progressEnd","createGesture","gestureName","gesturePriority","OVERLAY_GESTURE_PRIORITY","direction","toastIosCss","toastMdCss","Toast","constructor","hostRef","this","delegateController","createDelegateController","lockController","createLockController","triggerController","createTriggerController","customHTMLEnabled","config","get","ENABLE_HTML_CONTENT_DEFAULT","presented","dispatchCancelHandler","ev","role","isCancel","cancelButton","getButtons","find","b","callButtonHandler","createSwipeGesture","dismiss","undefined","GESTURE","destroySwipeGesture","prefersSwipeGesture","swipeGesture","revealContentToScreenReader","overlayIndex","delegate","hasController","color","enterAnimation","leaveAnimation","cssClass","getNumber","header","layout","message","keyboardClose","buttons","translucent","animated","icon","htmlAttributes","isOpen","trigger","swipeGestureChanged","lastPresentedPosition","onIsOpenChange","newValue","oldValue","present","triggerChanged","addClickListener","connectedCallback","prepareOverlay","disconnectedCallback","removeClickListener","componentWillLoad","setOverlayId","componentDidLoad","raf","unlock","lock","attachViewToDom","anchor","getAnchorElement","animationPosition","getIonMode","durationTimeout","setTimeout","data","_a","_b","clearTimeout","dismissed","removeViewFromDom","onDidDismiss","eventMethod","onWillDismiss","map","text","foundEl","document","getElementById","HTMLElement","buttonClick","button","Promise","resolve","handler","rtn","safeCall","e","console","error","renderButtons","side","length","buttonGroupsClasses","h","class","Object","assign","type","buttonClass","tabIndex","onClick","part","buttonPart","slot","renderToastMessage","key","ariaHidden","innerHTML","sanitizeDOMString","renderHeader","render","allButtons","startButtons","filter","endButtons","wrapperClass","Host","tabindex","zIndex","createColorClasses","getClassMap","onIonToastWillDismiss","lazy"],"sources":["node_modules/@ionic/core/dist/collection/components/toast/animations/utils.js","node_modules/@ionic/core/dist/collection/components/toast/animations/ios.enter.js","node_modules/@ionic/core/dist/collection/components/toast/animations/ios.leave.js","node_modules/@ionic/core/dist/collection/components/toast/animations/md.enter.js","node_modules/@ionic/core/dist/collection/components/toast/animations/md.leave.js","node_modules/@ionic/core/dist/collection/components/toast/gestures/swipe-to-dismiss.js","node_modules/@ionic/core/dist/collection/components/toast/toast.ios.css?tag=ion-toast&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/toast/toast.md.css?tag=ion-toast&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/toast/toast.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { win } from \"../../../utils/browser/index\";\nimport { printIonWarning } from \"../../../utils/logging/index\";\n/**\n * Calculate the CSS top and bottom position of the toast, to be used\n * as starting points for the animation keyframes.\n *\n * The default animations for both MD and iOS\n * use translateY, which calculates from the\n * top edge of the screen. This behavior impacts\n * how we compute the offset when a toast has\n * position='bottom' since we need to calculate from\n * the bottom edge of the screen instead.\n *\n * @param position The value of the toast's position prop.\n * @param positionAnchor The element the toast should be anchored to,\n * if applicable.\n * @param mode The toast component's mode (md, ios, etc).\n * @param toast A reference to the toast element itself.\n */\nexport function getAnimationPosition(position, positionAnchor, mode, toast) {\n    /**\n     * Start with a predefined offset from the edge the toast will be\n     * positioned relative to, whether on the screen or anchor element.\n     */\n    let offset;\n    if (mode === 'md') {\n        offset = position === 'top' ? 8 : -8;\n    }\n    else {\n        offset = position === 'top' ? 10 : -10;\n    }\n    /**\n     * If positionAnchor is defined, add in the distance from the target\n     * screen edge to the target anchor edge. For position=\"top\", the\n     * bottom anchor edge is targeted. For position=\"bottom\", the top\n     * anchor edge is targeted.\n     */\n    if (positionAnchor && win) {\n        warnIfAnchorIsHidden(positionAnchor, toast);\n        const box = positionAnchor.getBoundingClientRect();\n        if (position === 'top') {\n            offset += box.bottom;\n        }\n        else if (position === 'bottom') {\n            /**\n             * Just box.top is the distance from the top edge of the screen\n             * to the top edge of the anchor. We want to calculate from the\n             * bottom edge of the screen instead.\n             */\n            offset -= win.innerHeight - box.top;\n        }\n        /**\n         * We don't include safe area here because that should already be\n         * accounted for when checking the position of the anchor.\n         */\n        return {\n            top: `${offset}px`,\n            bottom: `${offset}px`,\n        };\n    }\n    else {\n        return {\n            top: `calc(${offset}px + var(--ion-safe-area-top, 0px))`,\n            bottom: `calc(${offset}px - var(--ion-safe-area-bottom, 0px))`,\n        };\n    }\n}\n/**\n * If the anchor element is hidden, getBoundingClientRect()\n * will return all 0s for it, which can cause unexpected\n * results in the position calculation when animating.\n */\nfunction warnIfAnchorIsHidden(positionAnchor, toast) {\n    if (positionAnchor.offsetParent === null) {\n        printIonWarning('The positionAnchor element for ion-toast was found in the DOM, but appears to be hidden. This may lead to unexpected positioning of the toast.', toast);\n    }\n}\n/**\n * Returns the top offset required to place\n * the toast in the middle of the screen.\n * Only needed when position=\"toast\".\n * @param toastHeight - The height of the ion-toast element\n * @param wrapperHeight - The height of the .toast-wrapper element\n * inside the toast's shadow root.\n */\nexport const getOffsetForMiddlePosition = (toastHeight, wrapperHeight) => {\n    return Math.floor(toastHeight / 2 - wrapperHeight / 2);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from \"../../../utils/animation/animation\";\nimport { getElementRoot } from \"../../../utils/helpers\";\nimport { getOffsetForMiddlePosition } from \"./utils\";\n/**\n * iOS Toast Enter Animation\n */\nexport const iosEnterAnimation = (baseEl, opts) => {\n    const baseAnimation = createAnimation();\n    const wrapperAnimation = createAnimation();\n    const { position, top, bottom } = opts;\n    const root = getElementRoot(baseEl);\n    const wrapperEl = root.querySelector('.toast-wrapper');\n    wrapperAnimation.addElement(wrapperEl);\n    switch (position) {\n        case 'top':\n            wrapperAnimation.fromTo('transform', 'translateY(-100%)', `translateY(${top})`);\n            break;\n        case 'middle':\n            const topPosition = getOffsetForMiddlePosition(baseEl.clientHeight, wrapperEl.clientHeight);\n            wrapperEl.style.top = `${topPosition}px`;\n            wrapperAnimation.fromTo('opacity', 0.01, 1);\n            break;\n        default:\n            wrapperAnimation.fromTo('transform', 'translateY(100%)', `translateY(${bottom})`);\n            break;\n    }\n    return baseAnimation.easing('cubic-bezier(.155,1.105,.295,1.12)').duration(400).addAnimation(wrapperAnimation);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from \"../../../utils/animation/animation\";\nimport { getElementRoot } from \"../../../utils/helpers\";\n/**\n * iOS Toast Leave Animation\n */\nexport const iosLeaveAnimation = (baseEl, opts) => {\n    const baseAnimation = createAnimation();\n    const wrapperAnimation = createAnimation();\n    const { position, top, bottom } = opts;\n    const root = getElementRoot(baseEl);\n    const wrapperEl = root.querySelector('.toast-wrapper');\n    wrapperAnimation.addElement(wrapperEl);\n    switch (position) {\n        case 'top':\n            wrapperAnimation.fromTo('transform', `translateY(${top})`, 'translateY(-100%)');\n            break;\n        case 'middle':\n            wrapperAnimation.fromTo('opacity', 0.99, 0);\n            break;\n        default:\n            wrapperAnimation.fromTo('transform', `translateY(${bottom})`, 'translateY(100%)');\n            break;\n    }\n    return baseAnimation.easing('cubic-bezier(.36,.66,.04,1)').duration(300).addAnimation(wrapperAnimation);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from \"../../../utils/animation/animation\";\nimport { getElementRoot } from \"../../../utils/helpers\";\nimport { getOffsetForMiddlePosition } from \"./utils\";\n/**\n * MD Toast Enter Animation\n */\nexport const mdEnterAnimation = (baseEl, opts) => {\n    const baseAnimation = createAnimation();\n    const wrapperAnimation = createAnimation();\n    const { position, top, bottom } = opts;\n    const root = getElementRoot(baseEl);\n    const wrapperEl = root.querySelector('.toast-wrapper');\n    wrapperAnimation.addElement(wrapperEl);\n    switch (position) {\n        case 'top':\n            wrapperEl.style.setProperty('transform', `translateY(${top})`);\n            wrapperAnimation.fromTo('opacity', 0.01, 1);\n            break;\n        case 'middle':\n            const topPosition = getOffsetForMiddlePosition(baseEl.clientHeight, wrapperEl.clientHeight);\n            wrapperEl.style.top = `${topPosition}px`;\n            wrapperAnimation.fromTo('opacity', 0.01, 1);\n            break;\n        default:\n            wrapperEl.style.setProperty('transform', `translateY(${bottom})`);\n            wrapperAnimation.fromTo('opacity', 0.01, 1);\n            break;\n    }\n    return baseAnimation.easing('cubic-bezier(.36,.66,.04,1)').duration(400).addAnimation(wrapperAnimation);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from \"../../../utils/animation/animation\";\nimport { getElementRoot } from \"../../../utils/helpers\";\n/**\n * md Toast Leave Animation\n */\nexport const mdLeaveAnimation = (baseEl) => {\n    const baseAnimation = createAnimation();\n    const wrapperAnimation = createAnimation();\n    const root = getElementRoot(baseEl);\n    const wrapperEl = root.querySelector('.toast-wrapper');\n    wrapperAnimation.addElement(wrapperEl).fromTo('opacity', 0.99, 0);\n    return baseAnimation.easing('cubic-bezier(.36,.66,.04,1)').duration(300).addAnimation(wrapperAnimation);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Build } from \"@stencil/core\";\nimport { createAnimation } from \"../../../utils/animation/animation\";\nimport { createGesture } from \"../../../utils/gesture/index\";\nimport { getElementRoot } from \"../../../utils/helpers\";\nimport { OVERLAY_GESTURE_PRIORITY } from \"../../../utils/overlays\";\nimport { getOffsetForMiddlePosition } from \"../animations/utils\";\n/**\n * Create a gesture that allows the Toast\n * to be swiped to dismiss.\n * @param el - The Toast element\n * @param toastPosition - The last computed position of the Toast. This is computed in the \"present\" method.\n * @param onDismiss - A callback to fire when the Toast was swiped to dismiss.\n */\nexport const createSwipeToDismissGesture = (el, toastPosition, onDismiss) => {\n    /**\n     * Users should swipe on the visible toast wrapper\n     * rather than on ion-toast which covers the entire screen.\n     * When testing the class instance the inner wrapper will not\n     * be defined. As a result, we use a placeholder element in those environments.\n     */\n    const wrapperEl = Build.isTesting\n        ? document.createElement('div')\n        : getElementRoot(el).querySelector('.toast-wrapper');\n    const hostElHeight = el.clientHeight;\n    const wrapperElBox = wrapperEl.getBoundingClientRect();\n    /**\n     * The maximum amount that\n     * the toast can be swiped. This should\n     * account for the wrapper element's height\n     * too so the toast can be swiped offscreen\n     * completely.\n     */\n    let MAX_SWIPE_DISTANCE = 0;\n    /**\n     * The step value at which a toast\n     * is eligible for dismissing via gesture.\n     */\n    const DISMISS_THRESHOLD = 0.5;\n    /**\n     * The middle position Toast starts 50% of the way\n     * through the animation, so we need to use this\n     * as the starting point for our step values.\n     */\n    const STEP_OFFSET = el.position === 'middle' ? 0.5 : 0;\n    /**\n     * When the Toast is at the top users will be\n     * swiping up. As a result, the delta values will be\n     * negative numbers which will result in negative steps\n     * and thresholds. As a result, we need to make those numbers\n     * positive.\n     */\n    const INVERSION_FACTOR = el.position === 'top' ? -1 : 1;\n    /**\n     * The top offset that places the\n     * toast in the middle of the screen.\n     * Only needed when position=\"middle\".\n     */\n    const topPosition = getOffsetForMiddlePosition(hostElHeight, wrapperElBox.height);\n    const SWIPE_UP_DOWN_KEYFRAMES = [\n        { offset: 0, transform: `translateY(-${topPosition + wrapperElBox.height}px)` },\n        { offset: 0.5, transform: `translateY(0px)` },\n        { offset: 1, transform: `translateY(${topPosition + wrapperElBox.height}px)` },\n    ];\n    const swipeAnimation = createAnimation('toast-swipe-to-dismiss-animation')\n        .addElement(wrapperEl)\n        /**\n         * The specific value here does not actually\n         * matter. We just need this to be a positive\n         * value so the animation does not jump\n         * to the end when the user beings to drag.\n         */\n        .duration(100);\n    switch (el.position) {\n        case 'middle':\n            MAX_SWIPE_DISTANCE = hostElHeight + wrapperElBox.height;\n            swipeAnimation.keyframes(SWIPE_UP_DOWN_KEYFRAMES);\n            /**\n             * Toast can be swiped up or down but\n             * should start in the middle of the screen.\n             */\n            swipeAnimation.progressStart(true, 0.5);\n            break;\n        case 'top':\n            /**\n             * The bottom edge of the wrapper\n             * includes the distance between the top\n             * of the screen and the top of the wrapper\n             * as well as the wrapper height so the wrapper\n             * can be dragged fully offscreen.\n             */\n            MAX_SWIPE_DISTANCE = wrapperElBox.bottom;\n            swipeAnimation.keyframes([\n                { offset: 0, transform: `translateY(${toastPosition.top})` },\n                { offset: 1, transform: 'translateY(-100%)' },\n            ]);\n            swipeAnimation.progressStart(true, 0);\n            break;\n        case 'bottom':\n        default:\n            /**\n             * This computes the distance between the\n             * top of the wrapper and the bottom of the\n             * screen including the height of the wrapper\n             * element so it can be dragged fully offscreen.\n             */\n            MAX_SWIPE_DISTANCE = hostElHeight - wrapperElBox.top;\n            swipeAnimation.keyframes([\n                { offset: 0, transform: `translateY(${toastPosition.bottom})` },\n                { offset: 1, transform: 'translateY(100%)' },\n            ]);\n            swipeAnimation.progressStart(true, 0);\n            break;\n    }\n    const computeStep = (delta) => {\n        return (delta * INVERSION_FACTOR) / MAX_SWIPE_DISTANCE;\n    };\n    const onMove = (detail) => {\n        const step = STEP_OFFSET + computeStep(detail.deltaY);\n        swipeAnimation.progressStep(step);\n    };\n    const onEnd = (detail) => {\n        const velocity = detail.velocityY;\n        const threshold = ((detail.deltaY + velocity * 1000) / MAX_SWIPE_DISTANCE) * INVERSION_FACTOR;\n        /**\n         * Disable the gesture for the remainder of the animation.\n         * It will be re-enabled if the toast animates back to\n         * its initial presented position.\n         */\n        gesture.enable(false);\n        let shouldDismiss = true;\n        let playTo = 1;\n        let step = 0;\n        let remainingDistance = 0;\n        if (el.position === 'middle') {\n            /**\n             * A middle positioned Toast appears\n             * in the middle of the screen (at animation offset 0.5).\n             * As a result, the threshold will be calculated relative\n             * to this starting position. In other words at animation offset 0.5\n             * the threshold will be 0. We want the middle Toast to be eligible\n             * for dismiss when the user has swiped either half way up or down the\n             * screen. As a result, we divide DISMISS_THRESHOLD in half. We also\n             * consider when the threshold is a negative in the event the\n             * user drags up (since the deltaY will also be negative).\n             */\n            shouldDismiss = threshold >= DISMISS_THRESHOLD / 2 || threshold <= -DISMISS_THRESHOLD / 2;\n            /**\n             * Since we are replacing the keyframes\n             * below the animation always starts from\n             * the beginning of the new keyframes.\n             * Similarly, we are always playing to\n             * the end of the new keyframes.\n             */\n            playTo = 1;\n            step = 0;\n            /**\n             * The Toast should animate from wherever its\n             * current position is to the desired end state.\n             *\n             * To begin, we get the current position of the\n             * Toast for its starting state.\n             */\n            const wrapperElBox = wrapperEl.getBoundingClientRect();\n            const startOffset = wrapperElBox.top - topPosition;\n            const startPosition = `${startOffset}px`;\n            /**\n             * If the deltaY is negative then the user is swiping\n             * up, so the Toast should animate to the top of the screen.\n             * If the deltaY is positive then the user is swiping\n             * down, so the Toast should animate to the bottom of the screen.\n             * We also account for when the deltaY is 0, but realistically\n             * that should never happen because it means the user did not drag\n             * the toast.\n             */\n            const offsetFactor = detail.deltaY <= 0 ? -1 : 1;\n            const endOffset = (topPosition + wrapperElBox.height) * offsetFactor;\n            /**\n             * If the Toast should dismiss\n             * then we need to figure out which edge of\n             * the screen it should animate towards.\n             * By default, the Toast will come\n             * back to its default state in the\n             * middle of the screen.\n             */\n            const endPosition = shouldDismiss ? `${endOffset}px` : '0px';\n            const KEYFRAMES = [\n                { offset: 0, transform: `translateY(${startPosition})` },\n                { offset: 1, transform: `translateY(${endPosition})` },\n            ];\n            swipeAnimation.keyframes(KEYFRAMES);\n            /**\n             * Compute the remaining amount of pixels the\n             * toast needs to move to be fully dismissed.\n             */\n            remainingDistance = endOffset - startOffset;\n        }\n        else {\n            shouldDismiss = threshold >= DISMISS_THRESHOLD;\n            playTo = shouldDismiss ? 1 : 0;\n            step = computeStep(detail.deltaY);\n            /**\n             * Compute the remaining amount of pixels the\n             * toast needs to move to be fully dismissed.\n             */\n            const remainingStepAmount = shouldDismiss ? 1 - step : step;\n            remainingDistance = remainingStepAmount * MAX_SWIPE_DISTANCE;\n        }\n        /**\n         * The animation speed should depend on how quickly\n         * the user flicks the toast across the screen. However,\n         * it should be no slower than 200ms.\n         * We use Math.abs on the remainingDistance because that value\n         * can be negative when swiping up on a middle position toast.\n         */\n        const duration = Math.min(Math.abs(remainingDistance) / Math.abs(velocity), 200);\n        swipeAnimation\n            .onFinish(() => {\n            if (shouldDismiss) {\n                onDismiss();\n                swipeAnimation.destroy();\n            }\n            else {\n                if (el.position === 'middle') {\n                    /**\n                     * If the toast snapped back to\n                     * the middle of the screen we need\n                     * to reset the keyframes\n                     * so the toast can be swiped\n                     * up or down again.\n                     */\n                    swipeAnimation.keyframes(SWIPE_UP_DOWN_KEYFRAMES).progressStart(true, 0.5);\n                }\n                else {\n                    swipeAnimation.progressStart(true, 0);\n                }\n                /**\n                 * If the toast did not dismiss then\n                 * the user should be able to swipe again.\n                 */\n                gesture.enable(true);\n            }\n            /**\n             * This must be a one time callback\n             * otherwise a new callback will\n             * be added every time onEnd runs.\n             */\n        }, { oneTimeCallback: true })\n            .progressEnd(playTo, step, duration);\n    };\n    const gesture = createGesture({\n        el: wrapperEl,\n        gestureName: 'toast-swipe-to-dismiss',\n        gesturePriority: OVERLAY_GESTURE_PRIORITY,\n        /**\n         * Toast only supports vertical swipes.\n         * This needs to be updated if we later\n         * support horizontal swipes.\n         */\n        direction: 'y',\n        onMove,\n        onEnd,\n    });\n    return gesture;\n};\n","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the toast\n   * @prop --color: Color of the toast text\n   *\n   * @prop --border-color: Border color of the toast\n   * @prop --border-radius: Border radius of the toast\n   * @prop --border-width: Border width of the toast\n   * @prop --border-style: Border style of the toast\n   *\n   * @prop --white-space: White space of the toast message\n   *\n   * @prop --box-shadow: Box shadow of the toast\n   *\n   * @prop --min-width: Minimum width of the toast\n   * @prop --width: Width of the toast\n   * @prop --max-width: Maximum width of the toast\n   *\n   * @prop --min-height: Minimum height of the toast\n   * @prop --height: Height of the toast\n   * @prop --max-height: Maximum height of the toast\n   *\n   * @prop --button-color: Color of the button text\n   *\n   * @prop --start: Position from the left if direction is left-to-right, and from the right if direction is right-to-left\n   * @prop --end: Position from the right if direction is left-to-right, and from the left if direction is right-to-left\n   */\n  --border-width: 0;\n  --border-style: none;\n  --border-color: initial;\n  --box-shadow: none;\n  --min-width: auto;\n  --width: auto;\n  --min-height: auto;\n  --height: auto;\n  --max-height: auto;\n  --white-space: normal;\n  top: 0;\n  display: block;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  outline: none;\n  color: var(--color);\n  font-family: var(--ion-font-family, inherit);\n  contain: strict;\n  z-index: 1001;\n  pointer-events: none;\n}\n@supports (inset-inline-start: 0) {\n  :host {\n    inset-inline-start: 0;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  :host {\n    left: 0;\n  }\n  :host-context([dir=rtl]) {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  @supports selector(:dir(rtl)) {\n    :host(:dir(rtl)) {\n      left: unset;\n      right: unset;\n      right: 0;\n    }\n  }\n}\n\n:host(.overlay-hidden) {\n  display: none;\n}\n\n:host(.ion-color) {\n  --button-color: inherit;\n  color: var(--ion-color-contrast);\n}\n\n:host(.ion-color) .toast-button-cancel {\n  color: inherit;\n}\n\n:host(.ion-color) .toast-wrapper {\n  background: var(--ion-color-base);\n}\n\n.toast-wrapper {\n  border-radius: var(--border-radius);\n  width: var(--width);\n  min-width: var(--min-width);\n  max-width: var(--max-width);\n  height: var(--height);\n  min-height: var(--min-height);\n  max-height: var(--max-height);\n  border-width: var(--border-width);\n  border-style: var(--border-style);\n  border-color: var(--border-color);\n  background: var(--background);\n  box-shadow: var(--box-shadow);\n}\n@supports (inset-inline-start: 0) {\n  .toast-wrapper {\n    inset-inline-start: var(--start);\n    inset-inline-end: var(--end);\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .toast-wrapper {\n    left: var(--start);\n    right: var(--end);\n  }\n  :host-context([dir=rtl]) .toast-wrapper {\n    left: unset;\n    right: unset;\n    left: var(--end);\n    right: var(--start);\n  }\n  [dir=rtl] .toast-wrapper {\n    left: unset;\n    right: unset;\n    left: var(--end);\n    right: var(--start);\n  }\n  @supports selector(:dir(rtl)) {\n    .toast-wrapper:dir(rtl) {\n      left: unset;\n      right: unset;\n      left: var(--end);\n      right: var(--start);\n    }\n  }\n}\n\n.toast-wrapper.toast-top {\n  transform: translate3d(0,  -100%,  0);\n  top: 0;\n}\n\n.toast-wrapper.toast-bottom {\n  transform: translate3d(0,  100%,  0);\n  bottom: 0;\n}\n\n.toast-container {\n  display: flex;\n  align-items: center;\n  pointer-events: auto;\n  height: inherit;\n  min-height: inherit;\n  max-height: inherit;\n  contain: content;\n}\n\n.toast-layout-stacked .toast-container {\n  flex-wrap: wrap;\n}\n\n.toast-layout-baseline .toast-content {\n  display: flex;\n  flex: 1;\n  flex-direction: column;\n  justify-content: center;\n}\n\n.toast-icon {\n  -webkit-margin-start: 16px;\n  margin-inline-start: 16px;\n}\n\n.toast-content {\n  min-width: 0;\n}\n\n.toast-message {\n  flex: 1;\n  white-space: var(--white-space);\n}\n\n.toast-button-group {\n  display: flex;\n}\n\n.toast-layout-stacked .toast-button-group {\n  justify-content: end;\n  width: 100%;\n}\n\n.toast-button {\n  border: 0;\n  outline: none;\n  color: var(--button-color);\n  z-index: 0;\n}\n\n.toast-icon,\n.toast-button-icon {\n  font-size: 1.4em;\n}\n\n.toast-button-inner {\n  display: flex;\n  align-items: center;\n}\n\n@media (any-hover: hover) {\n  .toast-button:hover {\n    cursor: pointer;\n  }\n}\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  --background: var(--ion-color-step-50, #f2f2f2);\n  --border-radius: 14px;\n  --button-color: var(--ion-color-primary, #3880ff);\n  --color: var(--ion-color-step-850, #262626);\n  --max-width: 700px;\n  --max-height: 478px;\n  --start: 10px;\n  --end: 10px;\n  font-size: clamp(14px, 0.875rem, 43.4px);\n}\n\n.toast-wrapper {\n  -webkit-margin-start: auto;\n  margin-inline-start: auto;\n  -webkit-margin-end: auto;\n  margin-inline-end: auto;\n  margin-top: auto;\n  margin-bottom: auto;\n  display: block;\n  position: absolute;\n  z-index: 10;\n}\n\n@supports (backdrop-filter: blur(0)) {\n  :host(.toast-translucent) .toast-wrapper {\n    background: rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);\n    backdrop-filter: saturate(180%) blur(20px);\n  }\n  :host(.ion-color.toast-translucent) .toast-wrapper {\n    background: rgba(var(--ion-color-base-rgb), 0.8);\n  }\n}\n.toast-wrapper.toast-middle {\n  opacity: 0.01;\n}\n\n.toast-content {\n  -webkit-padding-start: 15px;\n  padding-inline-start: 15px;\n  -webkit-padding-end: 15px;\n  padding-inline-end: 15px;\n  padding-top: 15px;\n  padding-bottom: 15px;\n}\n\n.toast-header {\n  margin-bottom: 2px;\n  font-weight: 500;\n}\n\n.toast-button {\n  -webkit-padding-start: 15px;\n  padding-inline-start: 15px;\n  -webkit-padding-end: 15px;\n  padding-inline-end: 15px;\n  padding-top: 10px;\n  padding-bottom: 10px;\n  min-height: 44px;\n  transition: background-color, opacity 100ms linear;\n  border: 0;\n  background-color: transparent;\n  font-family: var(--ion-font-family);\n  font-size: clamp(17px, 1.0625rem, 21.998px);\n  font-weight: 500;\n  overflow: hidden;\n}\n\n.toast-button.ion-activated {\n  opacity: 0.4;\n}\n\n@media (any-hover: hover) {\n  .toast-button:hover {\n    opacity: 0.6;\n  }\n}","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the toast\n   * @prop --color: Color of the toast text\n   *\n   * @prop --border-color: Border color of the toast\n   * @prop --border-radius: Border radius of the toast\n   * @prop --border-width: Border width of the toast\n   * @prop --border-style: Border style of the toast\n   *\n   * @prop --white-space: White space of the toast message\n   *\n   * @prop --box-shadow: Box shadow of the toast\n   *\n   * @prop --min-width: Minimum width of the toast\n   * @prop --width: Width of the toast\n   * @prop --max-width: Maximum width of the toast\n   *\n   * @prop --min-height: Minimum height of the toast\n   * @prop --height: Height of the toast\n   * @prop --max-height: Maximum height of the toast\n   *\n   * @prop --button-color: Color of the button text\n   *\n   * @prop --start: Position from the left if direction is left-to-right, and from the right if direction is right-to-left\n   * @prop --end: Position from the right if direction is left-to-right, and from the left if direction is right-to-left\n   */\n  --border-width: 0;\n  --border-style: none;\n  --border-color: initial;\n  --box-shadow: none;\n  --min-width: auto;\n  --width: auto;\n  --min-height: auto;\n  --height: auto;\n  --max-height: auto;\n  --white-space: normal;\n  top: 0;\n  display: block;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  outline: none;\n  color: var(--color);\n  font-family: var(--ion-font-family, inherit);\n  contain: strict;\n  z-index: 1001;\n  pointer-events: none;\n}\n@supports (inset-inline-start: 0) {\n  :host {\n    inset-inline-start: 0;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  :host {\n    left: 0;\n  }\n  :host-context([dir=rtl]) {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  @supports selector(:dir(rtl)) {\n    :host(:dir(rtl)) {\n      left: unset;\n      right: unset;\n      right: 0;\n    }\n  }\n}\n\n:host(.overlay-hidden) {\n  display: none;\n}\n\n:host(.ion-color) {\n  --button-color: inherit;\n  color: var(--ion-color-contrast);\n}\n\n:host(.ion-color) .toast-button-cancel {\n  color: inherit;\n}\n\n:host(.ion-color) .toast-wrapper {\n  background: var(--ion-color-base);\n}\n\n.toast-wrapper {\n  border-radius: var(--border-radius);\n  width: var(--width);\n  min-width: var(--min-width);\n  max-width: var(--max-width);\n  height: var(--height);\n  min-height: var(--min-height);\n  max-height: var(--max-height);\n  border-width: var(--border-width);\n  border-style: var(--border-style);\n  border-color: var(--border-color);\n  background: var(--background);\n  box-shadow: var(--box-shadow);\n}\n@supports (inset-inline-start: 0) {\n  .toast-wrapper {\n    inset-inline-start: var(--start);\n    inset-inline-end: var(--end);\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .toast-wrapper {\n    left: var(--start);\n    right: var(--end);\n  }\n  :host-context([dir=rtl]) .toast-wrapper {\n    left: unset;\n    right: unset;\n    left: var(--end);\n    right: var(--start);\n  }\n  [dir=rtl] .toast-wrapper {\n    left: unset;\n    right: unset;\n    left: var(--end);\n    right: var(--start);\n  }\n  @supports selector(:dir(rtl)) {\n    .toast-wrapper:dir(rtl) {\n      left: unset;\n      right: unset;\n      left: var(--end);\n      right: var(--start);\n    }\n  }\n}\n\n.toast-wrapper.toast-top {\n  transform: translate3d(0,  -100%,  0);\n  top: 0;\n}\n\n.toast-wrapper.toast-bottom {\n  transform: translate3d(0,  100%,  0);\n  bottom: 0;\n}\n\n.toast-container {\n  display: flex;\n  align-items: center;\n  pointer-events: auto;\n  height: inherit;\n  min-height: inherit;\n  max-height: inherit;\n  contain: content;\n}\n\n.toast-layout-stacked .toast-container {\n  flex-wrap: wrap;\n}\n\n.toast-layout-baseline .toast-content {\n  display: flex;\n  flex: 1;\n  flex-direction: column;\n  justify-content: center;\n}\n\n.toast-icon {\n  -webkit-margin-start: 16px;\n  margin-inline-start: 16px;\n}\n\n.toast-content {\n  min-width: 0;\n}\n\n.toast-message {\n  flex: 1;\n  white-space: var(--white-space);\n}\n\n.toast-button-group {\n  display: flex;\n}\n\n.toast-layout-stacked .toast-button-group {\n  justify-content: end;\n  width: 100%;\n}\n\n.toast-button {\n  border: 0;\n  outline: none;\n  color: var(--button-color);\n  z-index: 0;\n}\n\n.toast-icon,\n.toast-button-icon {\n  font-size: 1.4em;\n}\n\n.toast-button-inner {\n  display: flex;\n  align-items: center;\n}\n\n@media (any-hover: hover) {\n  .toast-button:hover {\n    cursor: pointer;\n  }\n}\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  --background: var(--ion-color-step-800, #333333);\n  --border-radius: 4px;\n  --box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12);\n  --button-color: var(--ion-color-primary, #3880ff);\n  --color: var(--ion-color-step-50, #f2f2f2);\n  --max-width: 700px;\n  --start: 8px;\n  --end: 8px;\n  font-size: 0.875rem;\n}\n\n.toast-wrapper {\n  -webkit-margin-start: auto;\n  margin-inline-start: auto;\n  -webkit-margin-end: auto;\n  margin-inline-end: auto;\n  margin-top: auto;\n  margin-bottom: auto;\n  display: block;\n  position: absolute;\n  opacity: 0.01;\n  z-index: 10;\n}\n\n.toast-content {\n  -webkit-padding-start: 16px;\n  padding-inline-start: 16px;\n  -webkit-padding-end: 16px;\n  padding-inline-end: 16px;\n  padding-top: 14px;\n  padding-bottom: 14px;\n}\n\n.toast-header {\n  margin-bottom: 2px;\n  font-weight: 500;\n  line-height: 1.25rem;\n}\n\n.toast-message {\n  line-height: 1.25rem;\n}\n\n.toast-layout-baseline .toast-button-group-start {\n  -webkit-margin-start: 8px;\n  margin-inline-start: 8px;\n}\n\n.toast-layout-stacked .toast-button-group-start {\n  -webkit-margin-end: 8px;\n  margin-inline-end: 8px;\n  margin-top: 8px;\n}\n\n.toast-layout-baseline .toast-button-group-end {\n  -webkit-margin-end: 8px;\n  margin-inline-end: 8px;\n}\n\n.toast-layout-stacked .toast-button-group-end {\n  -webkit-margin-end: 8px;\n  margin-inline-end: 8px;\n  margin-bottom: 8px;\n}\n\n.toast-button {\n  -webkit-padding-start: 15px;\n  padding-inline-start: 15px;\n  -webkit-padding-end: 15px;\n  padding-inline-end: 15px;\n  padding-top: 10px;\n  padding-bottom: 10px;\n  position: relative;\n  background-color: transparent;\n  font-family: var(--ion-font-family);\n  font-size: 0.875rem;\n  font-weight: 500;\n  letter-spacing: 0.84px;\n  text-transform: uppercase;\n  overflow: hidden;\n}\n\n.toast-button-cancel {\n  color: var(--ion-color-step-100, #e6e6e6);\n}\n\n.toast-button-icon-only {\n  border-radius: 50%;\n  -webkit-padding-start: 9px;\n  padding-inline-start: 9px;\n  -webkit-padding-end: 9px;\n  padding-inline-end: 9px;\n  padding-top: 9px;\n  padding-bottom: 9px;\n  width: 36px;\n  height: 36px;\n}\n\n@media (any-hover: hover) {\n  .toast-button:hover {\n    background-color: rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.08);\n  }\n  .toast-button-cancel:hover {\n    background-color: rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.08);\n  }\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { h, Host } from \"@stencil/core\";\nimport { ENABLE_HTML_CONTENT_DEFAULT } from \"../../utils/config\";\nimport { raf } from \"../../utils/helpers\";\nimport { createLockController } from \"../../utils/lock-controller\";\nimport { printIonWarning } from \"../../utils/logging/index\";\nimport { GESTURE, createDelegateController, createTriggerController, dismiss, eventMethod, isCancel, prepareOverlay, present, safeCall, setOverlayId, } from \"../../utils/overlays\";\nimport { sanitizeDOMString } from \"../../utils/sanitization/index\";\nimport { createColorClasses, getClassMap } from \"../../utils/theme\";\nimport { config } from \"../../global/config\";\nimport { getIonMode } from \"../../global/ionic-global\";\nimport { iosEnterAnimation } from \"./animations/ios.enter\";\nimport { iosLeaveAnimation } from \"./animations/ios.leave\";\nimport { mdEnterAnimation } from \"./animations/md.enter\";\nimport { mdLeaveAnimation } from \"./animations/md.leave\";\nimport { getAnimationPosition } from \"./animations/utils\";\nimport { createSwipeToDismissGesture } from \"./gestures/swipe-to-dismiss\";\n// TODO(FW-2832): types\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n *\n * @part button - Any button element that is displayed inside of the toast.\n * @part button cancel - Any button element with role \"cancel\" that is displayed inside of the toast.\n * @part container - The element that wraps all child elements.\n * @part header - The header text of the toast.\n * @part message - The body text of the toast.\n * @part icon - The icon that appears next to the toast content.\n */\nexport class Toast {\n    constructor() {\n        this.delegateController = createDelegateController(this);\n        this.lockController = createLockController();\n        this.triggerController = createTriggerController();\n        this.customHTMLEnabled = config.get('innerHTMLTemplatesEnabled', ENABLE_HTML_CONTENT_DEFAULT);\n        this.presented = false;\n        this.dispatchCancelHandler = (ev) => {\n            const role = ev.detail.role;\n            if (isCancel(role)) {\n                const cancelButton = this.getButtons().find((b) => b.role === 'cancel');\n                this.callButtonHandler(cancelButton);\n            }\n        };\n        /**\n         * Create a new swipe gesture so Toast\n         * can be swiped to dismiss.\n         */\n        this.createSwipeGesture = (toastPosition) => {\n            const gesture = (this.gesture = createSwipeToDismissGesture(this.el, toastPosition, () => {\n                /**\n                 * If the gesture completed then\n                 * we should dismiss the toast.\n                 */\n                this.dismiss(undefined, GESTURE);\n            }));\n            gesture.enable(true);\n        };\n        /**\n         * Destroy an existing swipe gesture\n         * so Toast can no longer be swiped to dismiss.\n         */\n        this.destroySwipeGesture = () => {\n            const { gesture } = this;\n            if (gesture === undefined) {\n                return;\n            }\n            gesture.destroy();\n            this.gesture = undefined;\n        };\n        /**\n         * Returns `true` if swipeGesture\n         * is configured to a value that enables the swipe behavior.\n         * Returns `false` otherwise.\n         */\n        this.prefersSwipeGesture = () => {\n            const { swipeGesture } = this;\n            return swipeGesture === 'vertical';\n        };\n        this.revealContentToScreenReader = false;\n        this.overlayIndex = undefined;\n        this.delegate = undefined;\n        this.hasController = false;\n        this.color = undefined;\n        this.enterAnimation = undefined;\n        this.leaveAnimation = undefined;\n        this.cssClass = undefined;\n        this.duration = config.getNumber('toastDuration', 0);\n        this.header = undefined;\n        this.layout = 'baseline';\n        this.message = undefined;\n        this.keyboardClose = false;\n        this.position = 'bottom';\n        this.positionAnchor = undefined;\n        this.buttons = undefined;\n        this.translucent = false;\n        this.animated = true;\n        this.icon = undefined;\n        this.htmlAttributes = undefined;\n        this.swipeGesture = undefined;\n        this.isOpen = false;\n        this.trigger = undefined;\n    }\n    swipeGestureChanged() {\n        /**\n         * If the Toast is presented, then we need to destroy\n         * any actives gestures before a new gesture is potentially\n         * created below.\n         *\n         * If the Toast is dismissed, then no gesture should be available\n         * since the Toast is not visible. This case should never\n         * happen since the \"dismiss\" method handles destroying\n         * any active swipe gestures, but we keep this code\n         * around to handle the first case.\n         */\n        this.destroySwipeGesture();\n        /**\n         * A new swipe gesture should only be created\n         * if the Toast is presented. If the Toast is not\n         * yet presented then the \"present\" method will\n         * handle calling the swipe gesture setup function.\n         */\n        if (this.presented && this.prefersSwipeGesture()) {\n            /**\n             * If the Toast is presented then\n             * lastPresentedPosition is defined.\n             */\n            this.createSwipeGesture(this.lastPresentedPosition);\n        }\n    }\n    onIsOpenChange(newValue, oldValue) {\n        if (newValue === true && oldValue === false) {\n            this.present();\n        }\n        else if (newValue === false && oldValue === true) {\n            this.dismiss();\n        }\n    }\n    triggerChanged() {\n        const { trigger, el, triggerController } = this;\n        if (trigger) {\n            triggerController.addClickListener(el, trigger);\n        }\n    }\n    connectedCallback() {\n        prepareOverlay(this.el);\n        this.triggerChanged();\n    }\n    disconnectedCallback() {\n        this.triggerController.removeClickListener();\n    }\n    componentWillLoad() {\n        setOverlayId(this.el);\n    }\n    componentDidLoad() {\n        /**\n         * If toast was rendered with isOpen=\"true\"\n         * then we should open toast immediately.\n         */\n        if (this.isOpen === true) {\n            raf(() => this.present());\n        }\n        /**\n         * When binding values in frameworks such as Angular\n         * it is possible for the value to be set after the Web Component\n         * initializes but before the value watcher is set up in Stencil.\n         * As a result, the watcher callback may not be fired.\n         * We work around this by manually calling the watcher\n         * callback when the component has loaded and the watcher\n         * is configured.\n         */\n        this.triggerChanged();\n    }\n    /**\n     * Present the toast overlay after it has been created.\n     */\n    async present() {\n        const unlock = await this.lockController.lock();\n        await this.delegateController.attachViewToDom();\n        const { el, position } = this;\n        const anchor = this.getAnchorElement();\n        const animationPosition = getAnimationPosition(position, anchor, getIonMode(this), el);\n        /**\n         * Cache the calculated position of the toast, so we can re-use it\n         * in the dismiss animation.\n         */\n        this.lastPresentedPosition = animationPosition;\n        await present(this, 'toastEnter', iosEnterAnimation, mdEnterAnimation, {\n            position,\n            top: animationPosition.top,\n            bottom: animationPosition.bottom,\n        });\n        /**\n         * Content is revealed to screen readers after\n         * the transition to avoid jank since this\n         * state updates will cause a re-render.\n         */\n        this.revealContentToScreenReader = true;\n        if (this.duration > 0) {\n            this.durationTimeout = setTimeout(() => this.dismiss(undefined, 'timeout'), this.duration);\n        }\n        /**\n         * If the Toast has a swipe gesture then we can\n         * create the gesture so users can swipe the\n         * presented Toast.\n         */\n        if (this.prefersSwipeGesture()) {\n            this.createSwipeGesture(animationPosition);\n        }\n        unlock();\n    }\n    /**\n     * Dismiss the toast overlay after it has been presented.\n     *\n     * @param data Any data to emit in the dismiss events.\n     * @param role The role of the element that is dismissing the toast.\n     * This can be useful in a button handler for determining which button was\n     * clicked to dismiss the toast.\n     * Some examples include: ``\"cancel\"`, `\"destructive\"`, \"selected\"`, and `\"backdrop\"`.\n     *\n     * This is a no-op if the overlay has not been presented yet. If you want\n     * to remove an overlay from the DOM that was never presented, use the\n     * [remove](https://developer.mozilla.org/en-US/docs/Web/API/Element/remove) method.\n     */\n    async dismiss(data, role) {\n        var _a, _b;\n        const unlock = await this.lockController.lock();\n        const { durationTimeout, position, lastPresentedPosition } = this;\n        if (durationTimeout) {\n            clearTimeout(durationTimeout);\n        }\n        const dismissed = await dismiss(this, data, role, 'toastLeave', iosLeaveAnimation, mdLeaveAnimation, \n        /**\n         * Fetch the cached position that was calculated back in the present\n         * animation. We always want to animate the dismiss from the same\n         * position the present stopped at, so the animation looks continuous.\n         */\n        {\n            position,\n            top: (_a = lastPresentedPosition === null || lastPresentedPosition === void 0 ? void 0 : lastPresentedPosition.top) !== null && _a !== void 0 ? _a : '',\n            bottom: (_b = lastPresentedPosition === null || lastPresentedPosition === void 0 ? void 0 : lastPresentedPosition.bottom) !== null && _b !== void 0 ? _b : '',\n        });\n        if (dismissed) {\n            this.delegateController.removeViewFromDom();\n            this.revealContentToScreenReader = false;\n        }\n        this.lastPresentedPosition = undefined;\n        /**\n         * If the Toast has a swipe gesture then we can\n         * safely destroy it now that it is dismissed.\n         */\n        this.destroySwipeGesture();\n        unlock();\n        return dismissed;\n    }\n    /**\n     * Returns a promise that resolves when the toast did dismiss.\n     */\n    onDidDismiss() {\n        return eventMethod(this.el, 'ionToastDidDismiss');\n    }\n    /**\n     * Returns a promise that resolves when the toast will dismiss.\n     */\n    onWillDismiss() {\n        return eventMethod(this.el, 'ionToastWillDismiss');\n    }\n    getButtons() {\n        const buttons = this.buttons\n            ? this.buttons.map((b) => {\n                return typeof b === 'string' ? { text: b } : b;\n            })\n            : [];\n        return buttons;\n    }\n    /**\n     * Returns the element specified by the positionAnchor prop,\n     * or undefined if prop's value is an ID string and the element\n     * is not found in the DOM.\n     */\n    getAnchorElement() {\n        const { position, positionAnchor, el } = this;\n        /**\n         * If positionAnchor is undefined then\n         * no anchor should be used when presenting the toast.\n         */\n        if (positionAnchor === undefined) {\n            return;\n        }\n        if (position === 'middle' && positionAnchor !== undefined) {\n            printIonWarning('The positionAnchor property is ignored when using position=\"middle\".', this.el);\n            return undefined;\n        }\n        if (typeof positionAnchor === 'string') {\n            /**\n             * If the anchor is defined as an ID, find the element.\n             * We do this on every present so the toast doesn't need\n             * to account for the surrounding DOM changing since the\n             * last time it was presented.\n             */\n            const foundEl = document.getElementById(positionAnchor);\n            if (foundEl === null) {\n                printIonWarning(`An anchor element with an ID of \"${positionAnchor}\" was not found in the DOM.`, el);\n                return undefined;\n            }\n            return foundEl;\n        }\n        if (positionAnchor instanceof HTMLElement) {\n            return positionAnchor;\n        }\n        printIonWarning('Invalid positionAnchor value:', positionAnchor, el);\n        return undefined;\n    }\n    async buttonClick(button) {\n        const role = button.role;\n        if (isCancel(role)) {\n            return this.dismiss(undefined, role);\n        }\n        const shouldDismiss = await this.callButtonHandler(button);\n        if (shouldDismiss) {\n            return this.dismiss(undefined, role);\n        }\n        return Promise.resolve();\n    }\n    async callButtonHandler(button) {\n        if (button === null || button === void 0 ? void 0 : button.handler) {\n            // a handler has been provided, execute it\n            // pass the handler the values from the inputs\n            try {\n                const rtn = await safeCall(button.handler);\n                if (rtn === false) {\n                    // if the return value of the handler is false then do not dismiss\n                    return false;\n                }\n            }\n            catch (e) {\n                console.error(e);\n            }\n        }\n        return true;\n    }\n    renderButtons(buttons, side) {\n        if (buttons.length === 0) {\n            return;\n        }\n        const mode = getIonMode(this);\n        const buttonGroupsClasses = {\n            'toast-button-group': true,\n            [`toast-button-group-${side}`]: true,\n        };\n        return (h(\"div\", { class: buttonGroupsClasses }, buttons.map((b) => (h(\"button\", Object.assign({}, b.htmlAttributes, { type: \"button\", class: buttonClass(b), tabIndex: 0, onClick: () => this.buttonClick(b), part: buttonPart(b) }), h(\"div\", { class: \"toast-button-inner\" }, b.icon && (h(\"ion-icon\", { \"aria-hidden\": \"true\", icon: b.icon, slot: b.text === undefined ? 'icon-only' : undefined, class: \"toast-button-icon\" })), b.text), mode === 'md' && (h(\"ion-ripple-effect\", { type: b.icon !== undefined && b.text === undefined ? 'unbounded' : 'bounded' })))))));\n    }\n    /**\n     * Render the `message` property.\n     * @param key - A key to give the element a stable identity. This is used to improve compatibility with screen readers.\n     * @param ariaHidden - If \"true\" then content will be hidden from screen readers.\n     */\n    renderToastMessage(key, ariaHidden = null) {\n        const { customHTMLEnabled, message } = this;\n        if (customHTMLEnabled) {\n            return (h(\"div\", { key: key, \"aria-hidden\": ariaHidden, class: \"toast-message\", part: \"message\", innerHTML: sanitizeDOMString(message) }));\n        }\n        return (h(\"div\", { key: key, \"aria-hidden\": ariaHidden, class: \"toast-message\", part: \"message\" }, message));\n    }\n    /**\n     * Render the `header` property.\n     * @param key - A key to give the element a stable identity. This is used to improve compatibility with screen readers.\n     * @param ariaHidden - If \"true\" then content will be hidden from screen readers.\n     */\n    renderHeader(key, ariaHidden = null) {\n        return (h(\"div\", { key: key, class: \"toast-header\", \"aria-hidden\": ariaHidden, part: \"header\" }, this.header));\n    }\n    render() {\n        const { layout, el, revealContentToScreenReader, header, message } = this;\n        const allButtons = this.getButtons();\n        const startButtons = allButtons.filter((b) => b.side === 'start');\n        const endButtons = allButtons.filter((b) => b.side !== 'start');\n        const mode = getIonMode(this);\n        const wrapperClass = {\n            'toast-wrapper': true,\n            [`toast-${this.position}`]: true,\n            [`toast-layout-${layout}`]: true,\n        };\n        /**\n         * Stacked buttons are only meant to be\n         *  used with one type of button.\n         */\n        if (layout === 'stacked' && startButtons.length > 0 && endButtons.length > 0) {\n            printIonWarning('This toast is using start and end buttons with the stacked toast layout. We recommend following the best practice of using either start or end buttons with the stacked toast layout.', el);\n        }\n        return (h(Host, Object.assign({ key: '23803334fb668f6ce7044d3a321cb84bc753bd16', tabindex: \"-1\" }, this.htmlAttributes, { style: {\n                zIndex: `${60000 + this.overlayIndex}`,\n            }, class: createColorClasses(this.color, Object.assign(Object.assign({ [mode]: true }, getClassMap(this.cssClass)), { 'overlay-hidden': true, 'toast-translucent': this.translucent })), onIonToastWillDismiss: this.dispatchCancelHandler }), h(\"div\", { key: '7cd7138ba079fccf97f318b91e9986491ab4214d', class: wrapperClass }, h(\"div\", { key: '93b78fa64e24435adeb77a04c1d1d53d2f093864', class: \"toast-container\", part: \"container\" }, this.renderButtons(startButtons, 'start'), this.icon !== undefined && (h(\"ion-icon\", { key: '9a3c71b164ebcfba2540acb7568beffa76b62f47', class: \"toast-icon\", part: \"icon\", icon: this.icon, lazy: false, \"aria-hidden\": \"true\" })), h(\"div\", { key: 'feb9268102d844f1314205f7440de7066cf0620e', class: \"toast-content\", role: \"status\", \"aria-atomic\": \"true\", \"aria-live\": \"polite\" }, !revealContentToScreenReader && header !== undefined && this.renderHeader('oldHeader', 'true'), !revealContentToScreenReader && message !== undefined && this.renderToastMessage('oldMessage', 'true'), revealContentToScreenReader && header !== undefined && this.renderHeader('header'), revealContentToScreenReader && message !== undefined && this.renderToastMessage('header')), this.renderButtons(endButtons, 'end')))));\n    }\n    static get is() { return \"ion-toast\"; }\n    static get encapsulation() { return \"shadow\"; }\n    static get originalStyleUrls() {\n        return {\n            \"ios\": [\"toast.ios.scss\"],\n            \"md\": [\"toast.md.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"ios\": [\"toast.ios.css\"],\n            \"md\": [\"toast.md.css\"]\n        };\n    }\n    static get properties() {\n        return {\n            \"overlayIndex\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number\",\n                    \"references\": {}\n                },\n                \"required\": true,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"\"\n                },\n                \"attribute\": \"overlay-index\",\n                \"reflect\": false\n            },\n            \"delegate\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"FrameworkDelegate\",\n                    \"resolved\": \"FrameworkDelegate | undefined\",\n                    \"references\": {\n                        \"FrameworkDelegate\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::FrameworkDelegate\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"\"\n                }\n            },\n            \"hasController\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"\"\n                },\n                \"attribute\": \"has-controller\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"color\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"Color\",\n                    \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n                    \"references\": {\n                        \"Color\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::Color\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n                },\n                \"attribute\": \"color\",\n                \"reflect\": true\n            },\n            \"enterAnimation\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"AnimationBuilder\",\n                    \"resolved\": \"((baseEl: any, opts?: any) => Animation) | undefined\",\n                    \"references\": {\n                        \"AnimationBuilder\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::AnimationBuilder\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Animation to use when the toast is presented.\"\n                }\n            },\n            \"leaveAnimation\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"AnimationBuilder\",\n                    \"resolved\": \"((baseEl: any, opts?: any) => Animation) | undefined\",\n                    \"references\": {\n                        \"AnimationBuilder\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::AnimationBuilder\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Animation to use when the toast is dismissed.\"\n                }\n            },\n            \"cssClass\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string | string[]\",\n                    \"resolved\": \"string | string[] | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Additional classes to apply for custom CSS. If multiple classes are\\nprovided they should be separated by spaces.\"\n                },\n                \"attribute\": \"css-class\",\n                \"reflect\": false\n            },\n            \"duration\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"How many milliseconds to wait before hiding the toast. By default, it will show\\nuntil `dismiss()` is called.\"\n                },\n                \"attribute\": \"duration\",\n                \"reflect\": false,\n                \"defaultValue\": \"config.getNumber('toastDuration', 0)\"\n            },\n            \"header\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string\",\n                    \"resolved\": \"string | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Header to be shown in the toast.\"\n                },\n                \"attribute\": \"header\",\n                \"reflect\": false\n            },\n            \"layout\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"ToastLayout\",\n                    \"resolved\": \"\\\"baseline\\\" | \\\"stacked\\\"\",\n                    \"references\": {\n                        \"ToastLayout\": {\n                            \"location\": \"import\",\n                            \"path\": \"./toast-interface\",\n                            \"id\": \"src/components/toast/toast-interface.ts::ToastLayout\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Defines how the message and buttons are laid out in the toast.\\n'baseline': The message and the buttons will appear on the same line.\\nMessage text may wrap within the message container.\\n'stacked': The buttons containers and message will stack on top\\nof each other. Use this if you have long text in your buttons.\"\n                },\n                \"attribute\": \"layout\",\n                \"reflect\": false,\n                \"defaultValue\": \"'baseline'\"\n            },\n            \"message\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string | IonicSafeString\",\n                    \"resolved\": \"IonicSafeString | string | undefined\",\n                    \"references\": {\n                        \"IonicSafeString\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../utils/sanitization\",\n                            \"id\": \"src/utils/sanitization/index.ts::IonicSafeString\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Message to be shown in the toast.\\nThis property accepts custom HTML as a string.\\nContent is parsed as plaintext by default.\\n`innerHTMLTemplatesEnabled` must be set to `true` in the Ionic config\\nbefore custom HTML can be used.\"\n                },\n                \"attribute\": \"message\",\n                \"reflect\": false\n            },\n            \"keyboardClose\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the keyboard will be automatically dismissed when the overlay is presented.\"\n                },\n                \"attribute\": \"keyboard-close\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"position\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"ToastPosition\",\n                    \"resolved\": \"\\\"bottom\\\" | \\\"middle\\\" | \\\"top\\\"\",\n                    \"references\": {\n                        \"ToastPosition\": {\n                            \"location\": \"import\",\n                            \"path\": \"./toast-interface\",\n                            \"id\": \"src/components/toast/toast-interface.ts::ToastPosition\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The starting position of the toast on the screen. Can be tweaked further\\nusing the `positionAnchor` property.\"\n                },\n                \"attribute\": \"position\",\n                \"reflect\": false,\n                \"defaultValue\": \"'bottom'\"\n            },\n            \"positionAnchor\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"HTMLElement | string\",\n                    \"resolved\": \"HTMLElement | string | undefined\",\n                    \"references\": {\n                        \"HTMLElement\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::HTMLElement\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The element to anchor the toast's position to. Can be set as a direct reference\\nor the ID of the element. With `position=\\\"bottom\\\"`, the toast will sit above the\\nchosen element. With `position=\\\"top\\\"`, the toast will sit below the chosen element.\\nWith `position=\\\"middle\\\"`, the value of `positionAnchor` is ignored.\"\n                },\n                \"attribute\": \"position-anchor\",\n                \"reflect\": false\n            },\n            \"buttons\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"(ToastButton | string)[]\",\n                    \"resolved\": \"(string | ToastButton)[] | undefined\",\n                    \"references\": {\n                        \"ToastButton\": {\n                            \"location\": \"import\",\n                            \"path\": \"./toast-interface\",\n                            \"id\": \"src/components/toast/toast-interface.ts::ToastButton\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"An array of buttons for the toast.\"\n                }\n            },\n            \"translucent\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the toast will be translucent.\\nOnly applies when the mode is `\\\"ios\\\"` and the device supports\\n[`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).\"\n                },\n                \"attribute\": \"translucent\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"animated\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the toast will animate.\"\n                },\n                \"attribute\": \"animated\",\n                \"reflect\": false,\n                \"defaultValue\": \"true\"\n            },\n            \"icon\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string\",\n                    \"resolved\": \"string | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The name of the icon to display, or the path to a valid SVG file. See `ion-icon`.\\nhttps://ionic.io/ionicons\"\n                },\n                \"attribute\": \"icon\",\n                \"reflect\": false\n            },\n            \"htmlAttributes\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"{ [key: string]: any }\",\n                    \"resolved\": \"undefined | { [key: string]: any; }\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Additional attributes to pass to the toast.\"\n                }\n            },\n            \"swipeGesture\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"ToastSwipeGestureDirection\",\n                    \"resolved\": \"\\\"vertical\\\" | undefined\",\n                    \"references\": {\n                        \"ToastSwipeGestureDirection\": {\n                            \"location\": \"import\",\n                            \"path\": \"./toast-interface\",\n                            \"id\": \"src/components/toast/toast-interface.ts::ToastSwipeGestureDirection\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If set to 'vertical', the Toast can be dismissed with\\na swipe gesture. The swipe direction is determined by\\nthe value of the `position` property:\\n`top`: The Toast can be swiped up to dismiss.\\n`bottom`: The Toast can be swiped down to dismiss.\\n`middle`: The Toast can be swiped up or down to dismiss.\"\n                },\n                \"attribute\": \"swipe-gesture\",\n                \"reflect\": false\n            },\n            \"isOpen\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the toast will open. If `false`, the toast will close.\\nUse this if you need finer grained control over presentation, otherwise\\njust use the toastController or the `trigger` property.\\nNote: `isOpen` will not automatically be set back to `false` when\\nthe toast dismisses. You will need to do that in your code.\"\n                },\n                \"attribute\": \"is-open\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"trigger\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string | undefined\",\n                    \"resolved\": \"string | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"An ID corresponding to the trigger element that\\ncauses the toast to open when clicked.\"\n                },\n                \"attribute\": \"trigger\",\n                \"reflect\": false\n            }\n        };\n    }\n    static get states() {\n        return {\n            \"revealContentToScreenReader\": {}\n        };\n    }\n    static get events() {\n        return [{\n                \"method\": \"didPresent\",\n                \"name\": \"ionToastDidPresent\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted after the toast has presented.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"willPresent\",\n                \"name\": \"ionToastWillPresent\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted before the toast has presented.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"willDismiss\",\n                \"name\": \"ionToastWillDismiss\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted before the toast has dismissed.\"\n                },\n                \"complexType\": {\n                    \"original\": \"OverlayEventDetail\",\n                    \"resolved\": \"OverlayEventDetail<any>\",\n                    \"references\": {\n                        \"OverlayEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../utils/overlays-interface\",\n                            \"id\": \"src/utils/overlays-interface.ts::OverlayEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"didDismiss\",\n                \"name\": \"ionToastDidDismiss\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted after the toast has dismissed.\"\n                },\n                \"complexType\": {\n                    \"original\": \"OverlayEventDetail\",\n                    \"resolved\": \"OverlayEventDetail<any>\",\n                    \"references\": {\n                        \"OverlayEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../utils/overlays-interface\",\n                            \"id\": \"src/utils/overlays-interface.ts::OverlayEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"didPresentShorthand\",\n                \"name\": \"didPresent\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted after the toast has presented.\\nShorthand for ionToastWillDismiss.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"willPresentShorthand\",\n                \"name\": \"willPresent\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted before the toast has presented.\\nShorthand for ionToastWillPresent.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"willDismissShorthand\",\n                \"name\": \"willDismiss\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted before the toast has dismissed.\\nShorthand for ionToastWillDismiss.\"\n                },\n                \"complexType\": {\n                    \"original\": \"OverlayEventDetail\",\n                    \"resolved\": \"OverlayEventDetail<any>\",\n                    \"references\": {\n                        \"OverlayEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../utils/overlays-interface\",\n                            \"id\": \"src/utils/overlays-interface.ts::OverlayEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"didDismissShorthand\",\n                \"name\": \"didDismiss\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted after the toast has dismissed.\\nShorthand for ionToastDidDismiss.\"\n                },\n                \"complexType\": {\n                    \"original\": \"OverlayEventDetail\",\n                    \"resolved\": \"OverlayEventDetail<any>\",\n                    \"references\": {\n                        \"OverlayEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../utils/overlays-interface\",\n                            \"id\": \"src/utils/overlays-interface.ts::OverlayEventDetail\"\n                        }\n                    }\n                }\n            }];\n    }\n    static get methods() {\n        return {\n            \"present\": {\n                \"complexType\": {\n                    \"signature\": \"() => Promise<void>\",\n                    \"parameters\": [],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        },\n                        \"ToastPresentOptions\": {\n                            \"location\": \"import\",\n                            \"path\": \"./toast-interface\",\n                            \"id\": \"src/components/toast/toast-interface.ts::ToastPresentOptions\"\n                        }\n                    },\n                    \"return\": \"Promise<void>\"\n                },\n                \"docs\": {\n                    \"text\": \"Present the toast overlay after it has been created.\",\n                    \"tags\": []\n                }\n            },\n            \"dismiss\": {\n                \"complexType\": {\n                    \"signature\": \"(data?: any, role?: string) => Promise<boolean>\",\n                    \"parameters\": [{\n                            \"name\": \"data\",\n                            \"type\": \"any\",\n                            \"docs\": \"Any data to emit in the dismiss events.\"\n                        }, {\n                            \"name\": \"role\",\n                            \"type\": \"string | undefined\",\n                            \"docs\": \"The role of the element that is dismissing the toast.\\nThis can be useful in a button handler for determining which button was\\nclicked to dismiss the toast.\\nSome examples include: ``\\\"cancel\\\"`, `\\\"destructive\\\"`, \\\"selected\\\"`, and `\\\"backdrop\\\"`.\\n\\nThis is a no-op if the overlay has not been presented yet. If you want\\nto remove an overlay from the DOM that was never presented, use the\\n[remove](https://developer.mozilla.org/en-US/docs/Web/API/Element/remove) method.\"\n                        }],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        },\n                        \"ToastDismissOptions\": {\n                            \"location\": \"import\",\n                            \"path\": \"./toast-interface\",\n                            \"id\": \"src/components/toast/toast-interface.ts::ToastDismissOptions\"\n                        }\n                    },\n                    \"return\": \"Promise<boolean>\"\n                },\n                \"docs\": {\n                    \"text\": \"Dismiss the toast overlay after it has been presented.\",\n                    \"tags\": [{\n                            \"name\": \"param\",\n                            \"text\": \"data Any data to emit in the dismiss events.\"\n                        }, {\n                            \"name\": \"param\",\n                            \"text\": \"role The role of the element that is dismissing the toast.\\nThis can be useful in a button handler for determining which button was\\nclicked to dismiss the toast.\\nSome examples include: ``\\\"cancel\\\"`, `\\\"destructive\\\"`, \\\"selected\\\"`, and `\\\"backdrop\\\"`.\\n\\nThis is a no-op if the overlay has not been presented yet. If you want\\nto remove an overlay from the DOM that was never presented, use the\\n[remove](https://developer.mozilla.org/en-US/docs/Web/API/Element/remove) method.\"\n                        }]\n                }\n            },\n            \"onDidDismiss\": {\n                \"complexType\": {\n                    \"signature\": \"<T = any>() => Promise<OverlayEventDetail<T>>\",\n                    \"parameters\": [],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        },\n                        \"OverlayEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../utils/overlays-interface\",\n                            \"id\": \"src/utils/overlays-interface.ts::OverlayEventDetail\"\n                        },\n                        \"T\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::T\"\n                        }\n                    },\n                    \"return\": \"Promise<OverlayEventDetail<T>>\"\n                },\n                \"docs\": {\n                    \"text\": \"Returns a promise that resolves when the toast did dismiss.\",\n                    \"tags\": []\n                }\n            },\n            \"onWillDismiss\": {\n                \"complexType\": {\n                    \"signature\": \"<T = any>() => Promise<OverlayEventDetail<T>>\",\n                    \"parameters\": [],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        },\n                        \"OverlayEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../utils/overlays-interface\",\n                            \"id\": \"src/utils/overlays-interface.ts::OverlayEventDetail\"\n                        },\n                        \"T\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::T\"\n                        }\n                    },\n                    \"return\": \"Promise<OverlayEventDetail<T>>\"\n                },\n                \"docs\": {\n                    \"text\": \"Returns a promise that resolves when the toast will dismiss.\",\n                    \"tags\": []\n                }\n            }\n        };\n    }\n    static get elementRef() { return \"el\"; }\n    static get watchers() {\n        return [{\n                \"propName\": \"swipeGesture\",\n                \"methodName\": \"swipeGestureChanged\"\n            }, {\n                \"propName\": \"isOpen\",\n                \"methodName\": \"onIsOpenChange\"\n            }, {\n                \"propName\": \"trigger\",\n                \"methodName\": \"triggerChanged\"\n            }];\n    }\n}\nconst buttonClass = (button) => {\n    return Object.assign({ 'toast-button': true, 'toast-button-icon-only': button.icon !== undefined && button.text === undefined, [`toast-button-${button.role}`]: button.role !== undefined, 'ion-focusable': true, 'ion-activatable': true }, getClassMap(button.cssClass));\n};\nconst buttonPart = (button) => {\n    return isCancel(button.role) ? 'button cancel' : 'button';\n};\n"],"mappings":"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","ignoreList":[]}
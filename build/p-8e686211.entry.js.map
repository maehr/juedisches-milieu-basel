{"version":3,"names":["reorderGroupCss","ReorderGroup","constructor","hostRef","this","lastToIndex","cachedHeights","scrollElTop","scrollElBottom","scrollElInitial","containerTop","containerBottom","state","disabled","disabledChanged","gesture","enable","connectedCallback","contentEl","findClosestIonContent","el","scrollEl","getScrollElement","import","createGesture","gestureName","gesturePriority","threshold","direction","passive","canStart","detail","onStart","ev","onMove","onEnd","disconnectedCallback","destroy","undefined","complete","listOrReorder","Promise","resolve","completeReorder","selectedItemEl","target","event","reorderEl","closest","item","findReorderItem","data","preventDefault","heights","length","children","sum","i","child","offsetHeight","push","$ionIndex","box","getBoundingClientRect","top","bottom","scrollBox","scrollTop","AUTO_SCROLL_MARGIN","indexForItem","selectedItemHeight","classList","add","ITEM_REORDER_SELECTED","hapticSelectionStart","selectedItem","scroll","autoscroll","currentY","Math","max","min","deltaY","startY","normalizedY","toIndex","itemIndexForTop","fromIndex","hapticSelectionChanged","reorderMove","style","transform","ionItemReorder","emit","from","to","bind","hapticSelectionEnd","len","raf","ref","insertBefore","Array","isArray","reorderArray","transition","remove","itemHeight","value","posY","amount","SCROLL_JUMP","scrollBy","render","mode","getIonMode","h","Host","key","class","element","node","container","parent","parentElement","array","splice","slice"],"sources":["node_modules/@ionic/core/dist/collection/components/reorder-group/reorder-group.css?tag=ion-reorder-group","node_modules/@ionic/core/dist/collection/components/reorder-group/reorder-group.js"],"sourcesContent":["/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n.reorder-list-active > * {\n  display: block;\n  transition: transform 300ms;\n  will-change: transform;\n}\n\n.reorder-enabled {\n  user-select: none;\n}\n\n.reorder-enabled ion-reorder {\n  display: block;\n  cursor: grab;\n  pointer-events: all;\n  touch-action: none;\n}\n\n.reorder-selected,\n.reorder-selected ion-reorder {\n  cursor: grabbing;\n}\n\n.reorder-selected {\n  position: relative;\n  /* stylelint-disable-next-line declaration-no-important */\n  transition: none !important;\n  box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);\n  opacity: 0.8;\n  z-index: 100;\n}\n\n.reorder-visible ion-reorder .reorder-icon {\n  transform: translate3d(0,  0,  0);\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from \"@stencil/core\";\nimport { findClosestIonContent, getScrollElement } from \"../../utils/content/index\";\nimport { raf } from \"../../utils/helpers\";\nimport { hapticSelectionChanged, hapticSelectionEnd, hapticSelectionStart } from \"../../utils/native/haptic\";\nimport { getIonMode } from \"../../global/ionic-global\";\nexport class ReorderGroup {\n    constructor() {\n        this.lastToIndex = -1;\n        this.cachedHeights = [];\n        this.scrollElTop = 0;\n        this.scrollElBottom = 0;\n        this.scrollElInitial = 0;\n        this.containerTop = 0;\n        this.containerBottom = 0;\n        this.state = 0 /* ReorderGroupState.Idle */;\n        this.disabled = true;\n    }\n    disabledChanged() {\n        if (this.gesture) {\n            this.gesture.enable(!this.disabled);\n        }\n    }\n    async connectedCallback() {\n        const contentEl = findClosestIonContent(this.el);\n        if (contentEl) {\n            this.scrollEl = await getScrollElement(contentEl);\n        }\n        this.gesture = (await import('../../utils/gesture')).createGesture({\n            el: this.el,\n            gestureName: 'reorder',\n            gesturePriority: 110,\n            threshold: 0,\n            direction: 'y',\n            passive: false,\n            canStart: (detail) => this.canStart(detail),\n            onStart: (ev) => this.onStart(ev),\n            onMove: (ev) => this.onMove(ev),\n            onEnd: () => this.onEnd(),\n        });\n        this.disabledChanged();\n    }\n    disconnectedCallback() {\n        this.onEnd();\n        if (this.gesture) {\n            this.gesture.destroy();\n            this.gesture = undefined;\n        }\n    }\n    /**\n     * Completes the reorder operation. Must be called by the `ionItemReorder` event.\n     *\n     * If a list of items is passed, the list will be reordered and returned in the\n     * proper order.\n     *\n     * If no parameters are passed or if `true` is passed in, the reorder will complete\n     * and the item will remain in the position it was dragged to. If `false` is passed,\n     * the reorder will complete and the item will bounce back to its original position.\n     *\n     * @param listOrReorder A list of items to be sorted and returned in the new order or a\n     * boolean of whether or not the reorder should reposition the item.\n     */\n    complete(listOrReorder) {\n        return Promise.resolve(this.completeReorder(listOrReorder));\n    }\n    canStart(ev) {\n        if (this.selectedItemEl || this.state !== 0 /* ReorderGroupState.Idle */) {\n            return false;\n        }\n        const target = ev.event.target;\n        const reorderEl = target.closest('ion-reorder');\n        if (!reorderEl) {\n            return false;\n        }\n        const item = findReorderItem(reorderEl, this.el);\n        if (!item) {\n            return false;\n        }\n        ev.data = item;\n        return true;\n    }\n    onStart(ev) {\n        ev.event.preventDefault();\n        const item = (this.selectedItemEl = ev.data);\n        const heights = this.cachedHeights;\n        heights.length = 0;\n        const el = this.el;\n        const children = el.children;\n        if (!children || children.length === 0) {\n            return;\n        }\n        let sum = 0;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            sum += child.offsetHeight;\n            heights.push(sum);\n            child.$ionIndex = i;\n        }\n        const box = el.getBoundingClientRect();\n        this.containerTop = box.top;\n        this.containerBottom = box.bottom;\n        if (this.scrollEl) {\n            const scrollBox = this.scrollEl.getBoundingClientRect();\n            this.scrollElInitial = this.scrollEl.scrollTop;\n            this.scrollElTop = scrollBox.top + AUTO_SCROLL_MARGIN;\n            this.scrollElBottom = scrollBox.bottom - AUTO_SCROLL_MARGIN;\n        }\n        else {\n            this.scrollElInitial = 0;\n            this.scrollElTop = 0;\n            this.scrollElBottom = 0;\n        }\n        this.lastToIndex = indexForItem(item);\n        this.selectedItemHeight = item.offsetHeight;\n        this.state = 1 /* ReorderGroupState.Active */;\n        item.classList.add(ITEM_REORDER_SELECTED);\n        hapticSelectionStart();\n    }\n    onMove(ev) {\n        const selectedItem = this.selectedItemEl;\n        if (!selectedItem) {\n            return;\n        }\n        // Scroll if we reach the scroll margins\n        const scroll = this.autoscroll(ev.currentY);\n        // // Get coordinate\n        const top = this.containerTop - scroll;\n        const bottom = this.containerBottom - scroll;\n        const currentY = Math.max(top, Math.min(ev.currentY, bottom));\n        const deltaY = scroll + currentY - ev.startY;\n        const normalizedY = currentY - top;\n        const toIndex = this.itemIndexForTop(normalizedY);\n        if (toIndex !== this.lastToIndex) {\n            const fromIndex = indexForItem(selectedItem);\n            this.lastToIndex = toIndex;\n            hapticSelectionChanged();\n            this.reorderMove(fromIndex, toIndex);\n        }\n        // Update selected item position\n        selectedItem.style.transform = `translateY(${deltaY}px)`;\n    }\n    onEnd() {\n        const selectedItemEl = this.selectedItemEl;\n        this.state = 2 /* ReorderGroupState.Complete */;\n        if (!selectedItemEl) {\n            this.state = 0 /* ReorderGroupState.Idle */;\n            return;\n        }\n        const toIndex = this.lastToIndex;\n        const fromIndex = indexForItem(selectedItemEl);\n        if (toIndex === fromIndex) {\n            this.completeReorder();\n        }\n        else {\n            this.ionItemReorder.emit({\n                from: fromIndex,\n                to: toIndex,\n                complete: this.completeReorder.bind(this),\n            });\n        }\n        hapticSelectionEnd();\n    }\n    completeReorder(listOrReorder) {\n        const selectedItemEl = this.selectedItemEl;\n        if (selectedItemEl && this.state === 2 /* ReorderGroupState.Complete */) {\n            const children = this.el.children;\n            const len = children.length;\n            const toIndex = this.lastToIndex;\n            const fromIndex = indexForItem(selectedItemEl);\n            /**\n             * insertBefore and setting the transform\n             * needs to happen in the same frame otherwise\n             * there will be a duplicate transition. This primarily\n             * impacts Firefox where insertBefore and transform operations\n             * are happening in two separate frames.\n             */\n            raf(() => {\n                if (toIndex !== fromIndex && (listOrReorder === undefined || listOrReorder === true)) {\n                    const ref = fromIndex < toIndex ? children[toIndex + 1] : children[toIndex];\n                    this.el.insertBefore(selectedItemEl, ref);\n                }\n                for (let i = 0; i < len; i++) {\n                    children[i].style['transform'] = '';\n                }\n            });\n            if (Array.isArray(listOrReorder)) {\n                listOrReorder = reorderArray(listOrReorder, fromIndex, toIndex);\n            }\n            selectedItemEl.style.transition = '';\n            selectedItemEl.classList.remove(ITEM_REORDER_SELECTED);\n            this.selectedItemEl = undefined;\n            this.state = 0 /* ReorderGroupState.Idle */;\n        }\n        return listOrReorder;\n    }\n    itemIndexForTop(deltaY) {\n        const heights = this.cachedHeights;\n        for (let i = 0; i < heights.length; i++) {\n            if (heights[i] > deltaY) {\n                return i;\n            }\n        }\n        return heights.length - 1;\n    }\n    /********* DOM WRITE ********* */\n    reorderMove(fromIndex, toIndex) {\n        const itemHeight = this.selectedItemHeight;\n        const children = this.el.children;\n        for (let i = 0; i < children.length; i++) {\n            const style = children[i].style;\n            let value = '';\n            if (i > fromIndex && i <= toIndex) {\n                value = `translateY(${-itemHeight}px)`;\n            }\n            else if (i < fromIndex && i >= toIndex) {\n                value = `translateY(${itemHeight}px)`;\n            }\n            style['transform'] = value;\n        }\n    }\n    autoscroll(posY) {\n        if (!this.scrollEl) {\n            return 0;\n        }\n        let amount = 0;\n        if (posY < this.scrollElTop) {\n            amount = -SCROLL_JUMP;\n        }\n        else if (posY > this.scrollElBottom) {\n            amount = SCROLL_JUMP;\n        }\n        if (amount !== 0) {\n            this.scrollEl.scrollBy(0, amount);\n        }\n        return this.scrollEl.scrollTop - this.scrollElInitial;\n    }\n    render() {\n        const mode = getIonMode(this);\n        return (h(Host, { key: '68b5e5fa00a0531c74597964d84c82da8bc3252f', class: {\n                [mode]: true,\n                'reorder-enabled': !this.disabled,\n                'reorder-list-active': this.state !== 0 /* ReorderGroupState.Idle */,\n            } }));\n    }\n    static get is() { return \"ion-reorder-group\"; }\n    static get originalStyleUrls() {\n        return {\n            \"$\": [\"reorder-group.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"$\": [\"reorder-group.css\"]\n        };\n    }\n    static get properties() {\n        return {\n            \"disabled\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the reorder will be hidden.\"\n                },\n                \"attribute\": \"disabled\",\n                \"reflect\": false,\n                \"defaultValue\": \"true\"\n            }\n        };\n    }\n    static get states() {\n        return {\n            \"state\": {}\n        };\n    }\n    static get events() {\n        return [{\n                \"method\": \"ionItemReorder\",\n                \"name\": \"ionItemReorder\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Event that needs to be listened to in order to complete the reorder action.\\nOnce the event has been emitted, the `complete()` method then needs\\nto be called in order to finalize the reorder action.\"\n                },\n                \"complexType\": {\n                    \"original\": \"ItemReorderEventDetail\",\n                    \"resolved\": \"ItemReorderEventDetail\",\n                    \"references\": {\n                        \"ItemReorderEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./reorder-group-interface\",\n                            \"id\": \"src/components/reorder-group/reorder-group-interface.ts::ItemReorderEventDetail\"\n                        }\n                    }\n                }\n            }];\n    }\n    static get methods() {\n        return {\n            \"complete\": {\n                \"complexType\": {\n                    \"signature\": \"(listOrReorder?: boolean | any[]) => Promise<any>\",\n                    \"parameters\": [{\n                            \"name\": \"listOrReorder\",\n                            \"type\": \"boolean | any[] | undefined\",\n                            \"docs\": \"A list of items to be sorted and returned in the new order or a\\nboolean of whether or not the reorder should reposition the item.\"\n                        }],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<any>\"\n                },\n                \"docs\": {\n                    \"text\": \"Completes the reorder operation. Must be called by the `ionItemReorder` event.\\n\\nIf a list of items is passed, the list will be reordered and returned in the\\nproper order.\\n\\nIf no parameters are passed or if `true` is passed in, the reorder will complete\\nand the item will remain in the position it was dragged to. If `false` is passed,\\nthe reorder will complete and the item will bounce back to its original position.\",\n                    \"tags\": [{\n                            \"name\": \"param\",\n                            \"text\": \"listOrReorder A list of items to be sorted and returned in the new order or a\\nboolean of whether or not the reorder should reposition the item.\"\n                        }]\n                }\n            }\n        };\n    }\n    static get elementRef() { return \"el\"; }\n    static get watchers() {\n        return [{\n                \"propName\": \"disabled\",\n                \"methodName\": \"disabledChanged\"\n            }];\n    }\n}\nconst indexForItem = (element) => {\n    return element['$ionIndex'];\n};\nconst findReorderItem = (node, container) => {\n    let parent;\n    while (node) {\n        parent = node.parentElement;\n        if (parent === container) {\n            return node;\n        }\n        node = parent;\n    }\n    return undefined;\n};\nconst AUTO_SCROLL_MARGIN = 60;\nconst SCROLL_JUMP = 10;\nconst ITEM_REORDER_SELECTED = 'reorder-selected';\nconst reorderArray = (array, from, to) => {\n    const element = array[from];\n    array.splice(from, 1);\n    array.splice(to, 0, element);\n    return array.slice();\n};\n"],"mappings":"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","ignoreList":[]}
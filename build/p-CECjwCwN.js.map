{"version":3,"file":"p-CECjwCwN.js","sources":["node_modules/@ionic/core/dist/collection/utils/forms/notch-controller.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { win } from \"../browser/index\";\nimport { raf } from \"../helpers\";\n/**\n * A utility to calculate the size of an outline notch\n * width relative to the content passed. This is used in\n * components such as `ion-select` with `fill=\"outline\"`\n * where we need to pass slotted HTML content. This is not\n * needed when rendering plaintext content because we can\n * render the plaintext again hidden with `opacity: 0` inside\n * of the notch. As a result we can rely on the intrinsic size\n * of the element to correctly compute the notch width. We\n * cannot do this with slotted content because we cannot project\n * it into 2 places at once.\n *\n * @internal\n * @param el: The host element\n * @param getNotchSpacerEl: A function that returns a reference to the notch spacer element inside of the component template.\n * @param getLabelSlot: A function that returns a reference to the slotted content.\n */\nexport const createNotchController = (el, getNotchSpacerEl, getLabelSlot) => {\n    let notchVisibilityIO;\n    const needsExplicitNotchWidth = () => {\n        const notchSpacerEl = getNotchSpacerEl();\n        if (\n        /**\n         * If the notch is not being used\n         * then we do not need to set the notch width.\n         */\n        notchSpacerEl === undefined ||\n            /**\n             * If either the label property is being\n             * used or the label slot is not defined,\n             * then we do not need to estimate the notch width.\n             */\n            el.label !== undefined ||\n            getLabelSlot() === null) {\n            return false;\n        }\n        return true;\n    };\n    const calculateNotchWidth = () => {\n        if (needsExplicitNotchWidth()) {\n            /**\n             * Run this the frame after\n             * the browser has re-painted the host element.\n             * Otherwise, the label element may have a width\n             * of 0 and the IntersectionObserver will be used.\n             */\n            raf(() => {\n                setNotchWidth();\n            });\n        }\n    };\n    /**\n     * When using a label prop we can render\n     * the label value inside of the notch and\n     * let the browser calculate the size of the notch.\n     * However, we cannot render the label slot in multiple\n     * places so we need to manually calculate the notch dimension\n     * based on the size of the slotted content.\n     *\n     * This function should only be used to set the notch width\n     * on slotted label content. The notch width for label prop\n     * content is automatically calculated based on the\n     * intrinsic size of the label text.\n     */\n    const setNotchWidth = () => {\n        const notchSpacerEl = getNotchSpacerEl();\n        if (notchSpacerEl === undefined) {\n            return;\n        }\n        if (!needsExplicitNotchWidth()) {\n            notchSpacerEl.style.removeProperty('width');\n            return;\n        }\n        const width = getLabelSlot().scrollWidth;\n        if (\n        /**\n         * If the computed width of the label is 0\n         * and notchSpacerEl's offsetParent is null\n         * then that means the element is hidden.\n         * As a result, we need to wait for the element\n         * to become visible before setting the notch width.\n         *\n         * We do not check el.offsetParent because\n         * that can be null if the host element has\n         * position: fixed applied to it.\n         * notchSpacerEl does not have position: fixed.\n         */\n        width === 0 &&\n            notchSpacerEl.offsetParent === null &&\n            win !== undefined &&\n            'IntersectionObserver' in win) {\n            /**\n             * If there is an IO already attached\n             * then that will update the notch\n             * once the element becomes visible.\n             * As a result, there is no need to create\n             * another one.\n             */\n            if (notchVisibilityIO !== undefined) {\n                return;\n            }\n            const io = (notchVisibilityIO = new IntersectionObserver((ev) => {\n                /**\n                 * If the element is visible then we\n                 * can try setting the notch width again.\n                 */\n                if (ev[0].intersectionRatio === 1) {\n                    setNotchWidth();\n                    io.disconnect();\n                    notchVisibilityIO = undefined;\n                }\n            }, \n            /**\n             * Set the root to be the host element\n             * This causes the IO callback\n             * to be fired in WebKit as soon as the element\n             * is visible. If we used the default root value\n             * then WebKit would only fire the IO callback\n             * after any animations (such as a modal transition)\n             * finished, and there would potentially be a flicker.\n             */\n            { threshold: 0.01, root: el }));\n            io.observe(notchSpacerEl);\n            return;\n        }\n        /**\n         * If the element is visible then we can set the notch width.\n         * The notch is only visible when the label is scaled,\n         * which is why we multiply the width by 0.75 as this is\n         * the same amount the label element is scaled by in the host CSS.\n         * (See $form-control-label-stacked-scale in ionic.globals.scss).\n         */\n        notchSpacerEl.style.setProperty('width', `${width * 0.75}px`);\n    };\n    const destroy = () => {\n        if (notchVisibilityIO) {\n            notchVisibilityIO.disconnect();\n            notchVisibilityIO = undefined;\n        }\n    };\n    return {\n        calculateNotchWidth,\n        destroy,\n    };\n};\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}